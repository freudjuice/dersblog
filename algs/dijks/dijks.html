<h1>Dijkstra Algoritması ile En Kısa Yol</h1>
<!DOCTYPE html>
<html>
  <head>
    <title>Dijkstra Algoritması ile En Kısa Yol
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [["$","$"]]}
      });
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"],
        bcancel: ["Extension","cancel"],
        xcancel: ["Extension","cancel"],
        cancelto: ["Extension","cancel"]
      });
    });
    </script>
<script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full">
</script>
</head>

<p>Elimizde alttaki gibi bir ağ yapısı var; bu yapı belli noktalar arasındaki
yolları, ya da elektrik devrelerindeki bağlantıları, ya da şehirler arası
nehirleri temsil ediyor olabilir. Ağ yapısında yolların ne kadar uzak, ya
da "pahalı" olduğu da verilmiş, ve bizim merak ettiğimiz bir noktadan
diğerine diğerine en kısa şekilde nasıl gidileceği.</p>
<p><img alt="" src="dijks_03.png" /></p>
<p>Üstteki resimdeki örnekte başlangıç noktası s'den bitiş noktası x'e diyelim
en kısa yol hangisi? Acaba s-y-z-x gidişi mi? Bu yolun toplamı 5+2+6=13
ediyor. Daha kısa yol var mıdır?</p>
<p>Dijkstra (telafuz <em>Daykstra</em>) algoritması bu sorunun cevabını veriyor
[1, sf. 659]. Algoritmanın işleyiş şekli şöyledir; elde bir öncelik kuyruğu
vardır, bakılacak olan yollar önce oraya konulur. Her noktanın, düğümün
sayısal ağırlığı onun başlangıca olan uzaklığıdır. Dikkat: onun bağlı
olduğu komşu düğümler değil, <em>başlangıca</em> olan uzaklığı. Algoritma işleyişi
sırasında bu ağırlığı değiştirebilir, eğer bir düğüme başlangıçtan daha
kısa bir yol bulunursa bu ağırlıkta değişim yapılacaktır, bu işleme
gevşetme (relaxing) ismi veriliyor.</p>
<p>Neyse; müstakbel düğümler kuyruğa konur. İlk başta kuyrukta sadece
başlangıç noktası s olacaktır, o kuyruktan çekilir, komşuları geri
konur. Komşuların ağırlığı tabii ki s ile komşular arasındaki
mesafedir. Öncelik kuyruğu ağırlık değerine göre otomatik olarak sıralama
yaptığı için bir düğüm çekildiğine en kısa yollu olan gelir. Kuyruktan
çekilen her düğümün ağırlığı artık o düğüme olan en kısa yol olarak kabul
edilir (niye - sebebine birazdan geleceğiz). Algoritma aynı şekilde devam
eder, çekilen düğümün komşuları alınıp kuyruğa konur, böyle gider.</p>
<p>Bazen aynı düğüme farklı yollardan erişmek mümkündür, bu durumda farklı
yolan erişilen düğümün ağırlığı daha "gevşetilebilir", mesela 10 iken 8
haline getirilebilir (örnekte t düğümünde bu oluyor), tabii ki bu durumda
düğümün kuyruktaki yeri de değişebilecekir, belki bir başka düğümün önüne
geçer.</p>
<pre><code class="python">from pqdict import pqdict

def dijkstra(G,basla,bitis):
    # nihai uzakliklarin sozlugu
    D = {}  
    # ebeveyn dugumlerin sozlugu
    P = {}  
    # dugumlerin baslangica olan tahmini uzakliginin kuyrugu
    Q = pqdict() 

    Q[basla] = 0

    while len(Q)&gt;0:
       (v,vv) = Q.popitem()
       D[v] = vv
       for w in G[v]:
          vwLength = D[v] + G[v][w]
          if w in D:
              if vwLength &lt; D[w]:
                  raise ValueError(&quot;sonuca giden daha iyi yol bulundu&quot;)
          elif w not in Q or vwLength &lt; Q[w]:
              Q[w] = vwLength
              P[w] = v
    path = []
    while 1:
       path.append(bitis)
       if bitis == basla: break
       bitis = P[bitis]
    path.reverse()
    return path

G = {'s':{'t':10, 'y':5}, 't':{'x':1, 'z':2}, 'x':{'z':4}, \
     'y':{'t':3, 'x':9, 'z':2}, 'z':{'s':7, 'x':6}}
path = dijkstra(G, 's', 'x')
print (path)
</code></pre>

<pre><code>['s', 'y', 't', 'x']
</code></pre>

<p>Kod en kısa yolu buldu. Bu algoritmanın hesaplama karmaşıklığı $m$ kenar
$n$ düğüm içeren bir çizit için $O((m+n) \log n)$'dir. Bu karmaşıklık hiç
fena değil. </p>
<p><img alt="" src="dijks_01.png" /></p>
<p><img alt="" src="dijks_02.png" /></p>
<p>Şekillerde görülen düğümler siyah renkli olunca  kuyruktan çekilmiş
demektir, ve onlara olan en kısa yol hesaplanmıştır. </p>
<p>Peki Dijkstra algoritmasının doğruluğundan nasıl emin olacağız?
Dijkstra'nın işleyişi sırasında sürekli iki tane kümeyi idare ettiğini
söyleyebiliriz. Bir küme öncelik kuyruğu içindeki müstakbel, diğeri ise ona
olan başlangıç uzaklığının artık bilindiği bitmiş düğümlerdir. İddia şu ki
öncelik kuyruğundan (en tepedeki, en yakın, ağırlığı en az) çektiğimiz her
düğüm ikinci kümeye transfer edilebilir, yani ona olan uzaklıktan
eminiz. Neden? Şimdi o düğüme gidebilecek daha kısa bir yol olduğunu farz
edelim. Fakat elimizdeki düğüme erişilirken diğer komşular değil ona
gelindi, çünkü ona gelen yol daha kısaydı, bu demektir ki komşular
üzerinden tur atarak elimizeki düğüme erişmek demek tanım itibariyle yolu
uzatmak demektir. Bu durumda kuyruktan çekilen düğümün ağırlığının ona
giden en kısa yol olduğuna güvenebiliriz. İspat tamamlandı.</p>
<p>Alttaki alternatif kod [2]'yi temel alıyor.</p>
<pre><code class="python">from heapq import heappush, heappop

inf = float('inf')
def relax(W, u, v, D, P):
    d = D.get(u,inf) + W[u][v]                  # Muhtemel kisayol tahmini
    if d &lt; D.get(v,inf):                        # Bu hakikaten bir kisa yol mu?
        D[v], P[v] = d, u                       # Tahmini ve ebeveyni guncelle
        return True                             # Degisim oldu

def dijkstra2(G, s, e):
    D, P, Q, S = {s:0}, {}, [(0,s)], set()      # Tahmin, agac, kuyruk, ziyaret?
    while Q:                                    # Hala islenmemis dugum?
        _, u = heappop(Q)                       # En dusuk tahminli dugum
        if u in S: continue                     # Coktan ziyaret edildi? Atla
        S.add(u)                                # Simdi ziyaret ettik
        for v in G[u]:                          # Tum komsularina bak
            relax(G, u, v, D, P)                # Disari cikan baglantiyi gevset
            heappush(Q, (D[v], v))              # Tahminiyle beraber kuyruga ekle
    path = []
    while 1:
        path.append(e)
        if e == s: break
        e = P[e]
    path.reverse()
    return path

path = dijkstra2(G, 's','x')
print path
</code></pre>

<pre><code>['s', 'y', 't', 'x']
</code></pre>

<p>Not: Aslında Dijkstra'nın ana hesabı bir düğüme olan başlangıçtan olan
uzaklıktır. Fakat çoğunlukla net bir "kısa yol", x,t,z,vs.. şeklinde
gerektiğinden algoritma işleyişi sırasında her düğüme giden bir önceki
düğüme geriye doğru bir işaret konur, bu ebeveyn düğümü eldeki düğüme
nereden gelindiğini hatırlamamızı sağlar. Sonra algoritma bitince bu yolu
geriye doğru takip ederek en kısa yolu buluruz.</p>
<p>Not: Eğer elimizdeki çizit yapısı öyle ki iki düğüm arasında iki yönlü
gidiş te mümkün ise algoritma değişir mi? Bu durumda algoritmaya dokunmadan
çizit ağ yapısında ufak bir değişiklik yeterli; a,b arasında bağlantı varsa
aynı şekilde bir b,a bağlantısı da ekleriz. </p>
<p>Java kodu <code>Dijkstra.java</code> dosyasında bulunabilir.</p>
<p>Problem</p>
<p>Diyelim ki elimizde bir çizit değil, öğeleri dünyadaki yükseklikleri temsil eden
bir matris var. Bir bölgedeki düzlüklerin, tepelerin yükseklikleri bu matriste
yani. Biz de bir noktadan diğerine 'en düz yoldan' gitmek istiyoruz, yani yokuş
yukarı mümkün olduğunca az gitmek amaçımiz.</p>
<p>Bu problem de aslında bir 'kısayol' problemi gibi görülebilir, daha doğrusu,
'en az bedel içeren yol' problemi. Eğer iki nokta arasındaki mesafeyi bir bedel
olarak görürsek en kısa yol en az bedelli yol haline gelir ve aynı Djikstra
algoritması ile çözülebilir.</p>
<p>Tabii her problem için veri yapısında biraz değişiklik olacaktır. Mesela çizit
yerine direk matris üzerinden çalışabilmek için, ve yükseklikleri baz almak
için, mesela her noktadaki 'komşuları' listelemek demek, o noktada, mesela
yakındaki 8 hücrenin içeriğine bakıp oradaki yükseklikleri mevcut hücrenin
yüksekliğinden çıkartmak bize bedeli verebilir. </p>
<p>Etraf derken etraftaki alt,üst,sağ,sol ile 4 hücreye, ya da 8 hücreye
bakılabilir, biz alttaki kodda 8 hücreyi temel aldık,</p>
<p><img alt="" src="dijks_04.jpg" /></p>
<pre><code class="python">from pqdict import pqdict
import numpy as np

def get_neighbor_idx(x,y,dims):
    res = []
    for i in ([0,-1,1]):
        for j in ([0,-1,1]):
            if i==0 and j==0: continue
            if x+i&lt;(dims[0]) and x+i&gt;-1 and y+j&lt;(dims[1]) and y+j&gt;-1:
                res.append((x+i,y+j))
    return res

def dijkstra(C,s,e):    
    D = {}
    P = {}
    Q = pqdict() 
    Q[s] = 0

    #for v in Q:
    while len(Q)&gt;0:
        (v,vv) = Q.popitem()
        D[v] = vv
        neighs = get_neighbor_idx(v[0],v[1],C.shape)
        for w in neighs:
            vwLength = D[v] + np.abs(C[v[0],v[1]] - C[w[0],w[1]])
            if w in D:
                if vwLength &lt; D[v]:
                    raise ValueError
            elif w not in Q or vwLength &lt; Q[w]:
                Q[w] = vwLength
                P[w] = v

    path = []
    while 1:
       path.append(e)
       if e == s: break
       e = P[e]
    path.reverse()
    return path   

m = np.array([[999.9, 999.9, 999.9,   0. ],
              [999.9, 999.9, 999.9,   0. ],
              [999.9, 999.9, 999.9,   0. ],
              [  0.,    0.,    0.,    0. ]])

res = dijkstra(m,(3,0),(0,3))

print (res)
</code></pre>

<pre><code>[[999.9 999.9 999.9   0. ]
 [999.9 999.9 999.9   0. ]
 [999.9 999.9 999.9   0. ]
 [  0.    0.    0.    0. ]]
[(3, 0), (3, 1), (3, 2), (2, 3), (1, 3), (0, 3)]
</code></pre>

<p>Görüldüğü gibi basit örnekte çoğu yerde 'dağlar' var, sol alttan başlayıp sağ
üst köşeye gitmek için en az bedelli alttan şeritten gitmek, sonra sağ alt
şeride zıplamak ve hedefe ulaşmak. Algoritma da aynen böyle yapıyor.</p>
<p>Kaynaklar</p>
<p>[1] Stein, <em>Introduction to Algorithms</em></p>
<p>[2] Heatland, <em>Python Algorithms</em></p>