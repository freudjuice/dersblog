\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Ýki Nokta Sýnýr Deðerli Problemler (Two-Point Boundary Value Problems -BVP-)

BVP problemleri þu genel formda olan problemlerdir [1, sf. 287],

$$ 
x''(t) = f(t, x(t), x'(t)))
$$

$$x(t_0) = x_0, \quad x(t_f) = x_f$$ 

Ýkinci satýr sýnýr þartlarýný belirtiyor, zaman için $t_0,t_1,...t_f$
indisleri kullanýlýr, yani sistemin konumu $x(t)$'in baþlangýçta $x_0$
bitiþte $x_f$ noktasýnda olmasý isteniyor (bunlar gerçek tek sayý deðerleri
olacak). Bilinmeyen bir baþlangýç þartý var, bu $x'(0)$ þartý, diyelim
$x'(0) = z$. Bilinmeyen $z$'yi nasýl bulacaðýz? Bu tür sistemlerin tipik
örneði top atýþý (silah anlamýnda) problemidir, güllenin nereden atýldýðý
bilinir, düþmesi istenen bir yer vardýr, ama hangi açýyla (burada $x'(0))$
yukarý doðru tutulacaðý bilinmez.

\includegraphics[width=20em]{compscieng_app10boundary_02.png}

Bilinmeyen baþlangýç þartlarýndan birini bulmak için bir yöntem tüm
bilinenleri kullanýp, bilinmeyen için bir tahmin yerine koymak, ve bu
sistemi entegre ederek sonuca gelmek. Sonuca gelindiðinde $x_f$'e ne kadar
yakýn olunduðuna göre bir hata gradyaný oluþturup bu gradyaný $x'(0)$'te
düzeltme yapmak için kullanmak, ve süreci tekrarlamak. Bu iþlem ardý ardýna
yapýlýr ve istenen bitiþ deðerine gelince durulur. Bu yönteme ilham aldýðý
temel örnekten hareketle atýþ metotu (the shooting method) adý veriliyor.

Gradyaný hesaplamak ve düzeltmede kullanmak için Sekant Yöntemini
kullanabiliriz (bkz {\em Diferansiyel Denklemler, Kök Bulmak} yazýsý). Hata
fonksiyonu $z$'nin fonksiyonudur,

$$ e(z) = x(t_f) - x_f $$

Ýstediðimiz $e(z)$'nin minimal olmasý, yani sýfýra eþit olmasý, $e(z) =
0$. Bu durumda bir kök bulma problemi ortaya çýkýyor,

$$ z_{n+1} = z_n - \frac{ \quad e(z_n) \quad }{\frac{\ud e(z_n) }{\ud z_n} }$$

Sekant yöntemi için

$$ z_{n+1} = z_n - 
\frac{ e(z_n)  }{\quad \dfrac{e(z_n) - e(z_{n-1})}{z_n - z_{n-1}} \quad }
$$

Örnek 

$$ x''(t) = 2x^2(t) + 4t x(t) x'(t)$$

$$ x(0) = \frac{1}{4}, \quad x(1) = \frac{1}{3}$$

Bu problemin analitik çözümü aslýnda biliniyor, 

$$x(t) = \frac{1}{4 - t^2}, \quad x'(t) = \frac{2t}{(4-t^2)^2} = 2t x^2(t)$$

Ama bilmeseydi nasýl çözerdik? Alttaki gibi. Önce $x_1'(t)$ için yeni bir
deðiþken tanýmlayalým, $x_1'(t) = x_2(t)$ olsun, o zaman $x_2'(t)$ ana ODE
denklemimiz olabilir, çok boyutlu olarak

$$ 
\left[\begin{array}{c}
x_1'(t) \\ x_2'(t) 
\end{array}\right] 
=
\left[\begin{array}{c}
x_2(t) \\
2x_1^2(t) + 4t \cdot x_1(t)x_2(t)
\end{array}\right] 
$$

Sýnýr þartlarý

$$ 
\left[\begin{array}{c}
x_1(0) \\ x_2(0)
\end{array}\right]
=
\left[\begin{array}{c}
x_0 = 1/4 \\ x_f = 1/3
\end{array}\right]
$$

Kod, 

\begin{minted}[fontsize=\footnotesize]{python}
import scipy as sp import numpy.linalg as lin from
scipy.integrate.odepack import odeint

def rhs(u,t):
    x1, x2,  = u
    return [x2, (2*x1 + 4*t*x2)*x1]

def bvp_shoot(t0,tf,x0,xf,N,tol,kmax):
    dx0 = np.zeros(kmax)
    e = np.zeros(kmax)
    dx0[0]= (xf-x0)/(tf-t0);
    t=np.linspace(t0,tf,100.0)
    for k in range(1,kmax-1):
        x=odeint(rhs,[x0, dx0[k]], t)        
        e[k]=x[-1,0]-xf
        ddx= dx0[k]-dx0[k-1]
        if np.abs(e[k])<tol or np.abs(ddx)<tol: break
        deddx= (e[k]-e[k-1])/ddx;
        dx0[k+1] = dx0[k]-e[k]/deddx;
    return t, x

t0 = 0.; tf = 1.; x0 = 1/4.; xf = 1/3.;
N = 100.; tol = 1e-8; kmax = 10;

t,x = bvp_shoot(t0,tf,x0,xf,N,tol,kmax)
xo = 1.0 /(4.0 - t**2); err = lin.norm(x[:,0] - xo)/(N + 1.0)

plt.plot(t,x[:,0],'g') # bizim hesap
plt.plot(t,xo,'--r') # analitik bilinen
plt.savefig('compscieng_app10boundary_01.png')
\end{minted}

\includegraphics[width=20em]{compscieng_app10boundary_01.png}

Grafikte görüldüðü gibi iki çözüm birbirinin týpký aynýsý. 

Bratu Problemi

Paket çözümleri de kullanýlabilir [2, sf. 396]. Mesela \verb!scipy!.

Bu problem 

$$
y'' + k + \exp(y) = 0
$$

$$
y(0) = y(1) = 0
$$

olarak bilinir. Bu sistemi 1. derece bir sistem olarak deðiþtirelim,

$$
y_1' = y_2
$$

$$
y_2' = -\exp(y_1)
$$

\begin{minted}[fontsize=\footnotesize]{python}
def fun(x, y):
    # k=1 farz edildi
    return np.vstack((y[1], -np.exp(y[0])))

def bc(ya, yb):
    return np.array([ya[0], yb[0]])

x = np.linspace(0, 1, 5)
\end{minted}


Bu problemin iki farklý çözümü var. Her iki çözümü de elde etmek için
$y$ için farklý baþlangýç noktalarý deneyeceðiz, bu seçenekleri $a$ ve
$b$ olarak iþaretleyelim,

\begin{minted}[fontsize=\footnotesize]{python}
y_a = np.zeros((2, x.size))
y_b = np.zeros((2, x.size))
y_b[0] = 3

from scipy.integrate import solve_bvp
res_a = solve_bvp(fun, bc, x, y_a)
res_b = solve_bvp(fun, bc, x, y_b)
\end{minted}

\begin{minted}[fontsize=\footnotesize]{python}
x_plot = np.linspace(0, 1, 100)
y_plot_a = res_a.sol(x_plot)[0]
y_plot_b = res_b.sol(x_plot)[0]
import matplotlib.pyplot as plt
plt.plot(x_plot, y_plot_a, label='y_a')

plt.plot(x_plot, y_plot_b, label='y_b')
plt.legend()
plt.xlabel("x")
plt.ylabel("y")
plt.savefig('compscieng_app10boundary_03.png')
\end{minted}


\includegraphics[width=20em]{compscieng_app10boundary_03.png}


Kaynaklar

[1] Yang, {\em Applied Numerical Methods using Matlab}

[2] Scipy, {\em Scipy Reference, 0.18.1}

\end{document}

