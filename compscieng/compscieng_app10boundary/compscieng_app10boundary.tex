\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Ýki Nokta Sýnýr Deðerli Problemler (Two-Point Boundary Value Problems -TPBVP-)

BVP problemleri þu genel formda olan problemlerdir [1, sf. 287],

$$ 
x''(t) = f(t, x(t), x'(t)))
$$

$$x(t_0) = x_0, \quad x(t_f) = x_f$$ 

Ýkinci satýr sýnýr þartlarýný belirtiyor, zaman için $t_0,t_1,...t_f$
indisleri kullanýlýr, yani sistemýn konumu $x(t)$'in baþlangýçta $x_0$
bitiþte $x_f$ noktasýnda olmasý isteniyor (bunlar gerçek tek sayý deðerleri
olacak). Bilinmeyen bir baþlangýç þartý var, bu $x'(0)$ þartý, diyelim
$x'(0) = z$. Bilinmeyen $z$'yi nasýl bulacaðýz? Genel yaklaþým olarak
bilinen az sayýda deðiþkeni ileri doðru entegre ederek sonda gelinen
noktaya bakýlýr, eldeki kýsmý son nokta verisiyle karþýlaþtýrýlarak bir
hata üzerinden baþlangýç düzeltilmeye uðraþýlýr, bu özyineli þekilde devam
eder. Çözüm yöntemi olarak ateþ etme yöntemi (the shooting method) vardýr,
farklý paketler farklý yaklaþýmlar kullanabilir. 

Paket Ýle

$$
\frac{\ud y}{\ud x} = f(x, y, p) + \frac{S y}{x-a}
$$

$$
a \le x \le b, \quad bc(y(a), y(b), p) = 0
$$

ki $x$ tek boyutlu baðýmsýz deðiþken, $y(x)$ n-boyutlu vektör deðerli
fonksiyon, $p$ $k$ boyutlu bilinmeyen parametrelerin vektörü, ki onu
$y(x)$'yi bulurken ayný anda bulmak gerekiyor. $bc$ ile sýnýr þartlarý
tanýmlanýyor.


Bratu Problemi

Paket çözümleri de kullanýlabilir [2, sf. 396]. Mesela \verb!scipy!. Bratu
problemi

$$
y'' + k + \exp(y) = 0
$$

$$
y(0) = y(1) = 0
$$

Bu sistemi 1. derece bir denklemler sistemine deðiþtirelim,

$$
y_1' = y_2
$$

$$
y_2' = -\exp(y_1)
$$

\begin{minted}[fontsize=\footnotesize]{python}
def fun(x, y):
    # k=1 farz edildi
    return np.vstack((y[1], -np.exp(y[0])))

def bc(ya, yb):
    return np.array([ya[0], yb[0]])

x = np.linspace(0, 1, 5)
\end{minted}

Çaðrý \verb!bc! içinde sýnýr þartlarýnýn artýðý, hatasý donduruluyor. Daha
doðrusu \verb!bc!'ye verilen iki parametre içinde baþta ve sonda olmak
üzere $y = [y_1,y_2]$ formatýnda artýk deðerler var. Bu artýklardan
hangisinin belirlediðimiz sýnýr þartýna ait olaný biz seçiyoruz. Mesela
\verb!ya[0]! ve \verb!yb[0]! ile içinde $y_1$'in baþta ve sondaki deðerini
seçmiþ oluyoruz, ki zaten problemin sýnýr þartlarý onlar üzerinden
tanýmlanmýþtý. Eðer $y_1'$, yani $y_2$ üzerinde bir son þart olsaydý o
zaman \verb!yb! 1. indisteki deðeri döndürürdük. Ayrýca artýkler hep sýfýra
eþitlik üzerinden tanýmlanýr, eðer $y_1(0)=k$ gibi bir sýnýr deðeri var
ise, $ya[0]-k$ döndürmemiz gerekir.

Bu problemin iki farklý çözümü var. Her iki çözümü de elde etmek için
$y$ için farklý baþlangýç noktalarý deneyeceðiz, bu seçenekleri $1$ ve
$2$ olarak iþaretleyelim,

\begin{minted}[fontsize=\footnotesize]{python}
y_1 = np.zeros((2, x.size))
y_2 = np.zeros((2, x.size))
y_2[0] = 3

from scipy.integrate import solve_bvp
res_1 = solve_bvp(fun, bc, x, y_1)
res_2 = solve_bvp(fun, bc, x, y_2)
\end{minted}

\begin{minted}[fontsize=\footnotesize]{python}
x_plot = np.linspace(0, 1, 100)
y_plot_1 = res_1.sol(x_plot)[0]
y_plot_2 = res_2.sol(x_plot)[0]

plt.plot(x_plot, y_plot_1, label='y_a')
plt.plot(x_plot, y_plot_2, label='y_b')
plt.legend()
plt.xlabel("x")
plt.ylabel("y")
plt.savefig('compscieng_app10boundary_03.png')
\end{minted}


\includegraphics[width=20em]{compscieng_app10boundary_03.png}


Top Atýþý Metotu (Shooting Method)

Bir diðer çözüm yöntemi top atýþý (silah anlamýnda) problemidir, güllenin
nereden atýldýðý bilinir, düþmesi istenen bir yer vardýr, ama hangi açýyla
(burada $x'(0))$ yukarý doðru tutulacaðý bilinmez.

\includegraphics[width=20em]{compscieng_app10boundary_02.png}

Bilinmeyen baþlangýç þartlarýndan birini bulmak için bir yöntem tüm
bilinenleri kullanýp, bilinmeyen için bir tahmin yerine koymak, ve bu
sistemi entegre ederek sonuca gelmek. Sonuca gelindiðinde $x_f$'e ne kadar
yakýn olunduðuna göre bir hata gradyaný oluþturup bu gradyaný $x'(0)$'te
düzeltme yapmak için kullanmak, ve süreci tekrarlamak. Bu iþlem ardý ardýna
yapýlýr ve istenen bitiþ deðerine gelince durulur. Bu yönteme ilham aldýðý
temel örnekten hareketle atýþ metotu (the shooting method) adý veriliyor.

Gradyaný hesaplamak ve düzeltmede kullanmak için Sekant Yöntemini
kullanabiliriz (bkz {\em Diferansiyel Denklemler, Kök Bulmak} yazýsý). Hata
fonksiyonu $z$'nin fonksiyonudur,

$$ e(z) = x(t_f) - x_f $$

Ýstediðimiz $e(z)$'nin minimal olmasý, yani sýfýra eþit olmasý, $e(z) =
0$. Bu durumda bir kök bulma problemi ortaya çýkýyor,

$$ z_{n+1} = z_n - \frac{ \quad e(z_n) \quad }{\frac{\ud e(z_n) }{\ud z_n} }$$

Sekant yöntemi için

$$ z_{n+1} = z_n - 
\frac{ e(z_n)  }{\quad \dfrac{e(z_n) - e(z_{n-1})}{z_n - z_{n-1}} \quad }
$$

Örnek 

$$ x''(t) = 2x^2(t) + 4t x(t) x'(t)$$

$$ x(0) = \frac{1}{4}, \quad x(1) = \frac{1}{3}$$

Bu problemin analitik çözümü aslýnda biliniyor, 

$$x(t) = \frac{1}{4 - t^2}, \quad x'(t) = \frac{2t}{(4-t^2)^2} = 2t x^2(t)$$

Ama bilmeseydik nasýl çözerdik? Alttaki gibi. Önce $x_1'(t)$ için yeni bir
deðiþken tanýmlayalým, $x_1'(t) = x_2(t)$ olsun, o zaman $x_2'(t)$ ana ODE
denklemimiz olabilir, çok boyutlu olarak

$$ 
\left[\begin{array}{c}
x_1'(t) \\ x_2'(t) 
\end{array}\right] 
=
\left[\begin{array}{c}
x_2(t) \\
2x_1^2(t) + 4t \cdot x_1(t)x_2(t)
\end{array}\right] 
$$

Sýnýr þartlarý

$$ 
\left[\begin{array}{c}
x_1(0) \\ x_2(0)
\end{array}\right]
=
\left[\begin{array}{c}
x_0 = 1/4 \\ x_f = 1/3
\end{array}\right]
$$

Kod, 

\begin{minted}[fontsize=\footnotesize]{python}
import scipy as sp import numpy.linalg as lin from
scipy.integrate.odepack import odeint

def rhs(u,t):
    x1, x2,  = u
    return [x2, (2*x1 + 4*t*x2)*x1]

def bvp_shoot(t0,tf,x0,xf,N,tol,kmax):
    dx0 = np.zeros(kmax)
    e = np.zeros(kmax)
    dx0[0]= (xf-x0)/(tf-t0);
    t=np.linspace(t0,tf,100.0)
    for k in range(1,kmax-1):
        x=odeint(rhs,[x0, dx0[k]], t)        
        e[k]=x[-1,0]-xf
        ddx= dx0[k]-dx0[k-1]
        if np.abs(e[k])<tol or np.abs(ddx)<tol: break
        deddx= (e[k]-e[k-1])/ddx;
        dx0[k+1] = dx0[k]-e[k]/deddx;
    return t, x

t0 = 0.; tf = 1.; x0 = 1/4.; xf = 1/3.;
N = 100.; tol = 1e-8; kmax = 10;

t,x = bvp_shoot(t0,tf,x0,xf,N,tol,kmax)
xo = 1.0 /(4.0 - t**2); err = lin.norm(x[:,0] - xo)/(N + 1.0)

plt.plot(t,x[:,0],'g') # bizim hesap
plt.plot(t,xo,'--r') # analitik bilinen
plt.savefig('compscieng_app10boundary_01.png')
\end{minted}

\includegraphics[width=20em]{compscieng_app10boundary_01.png}

Grafikte görüldüðü gibi iki çözüm birbirinin týpký aynýsý. 

Sturm-Liouville

Yine paket ile devam edelim. Sturm-Liouville adlý bir problemi çözelim, 

$$
y'' + k^y = 0
$$

$$
y(0) = y(1) = 0
$$

Bu problemin $n$ bir tam sayý olmak üzere $k = n \pi$ için bariz / önemsiz
olmayan bir çözümünün $y=A\sin(kx)$ olduðu biliniyor. $A=1$ ile normalizasyon
saðlamak için bir sýnýr þart daha ekliyoruz,

$$
y'(0) = k
$$

Çünkü $y=A\sin(kx) \to y' = A k \cos(kx)$, ve $y'(0)$ dersek
$y'(0) = A k \cos(0)) = A k$ olacaktýr, o zaman $y'(0) = k$ þartýný
koyarsak $A=1$'i zorlamýþ oluruz. 

1. derece sisteme çevirirsek,

$$
y_1' = y_2
$$

$$
y_2' = -k^2 y_1
$$

Ayrýca $k\pi$ için bir çözüm aradýðýmýz için $y$ deðerlerinin aþaðý yukarý
$\sin(2\pi x)$'yi takip etmesini saðlýyoruz,

\begin{minted}[fontsize=\footnotesize]{python}
from scipy.integrate import solve_bvp

def fun(x, y, p):
    k = p[0]
    return np.vstack((y[1], -k**2 * y[0]))

def bc(ya, yb, p):
    k = p[0]
    return np.array([ya[0], yb[0], ya[1] - k])

x = np.linspace(0, 1, 5)
y = np.zeros((2, x.size))
y[0, 1] = 1
y[0, 3] = -1

sol = solve_bvp(fun, bc, x, y, p=[6])
print (sol.p)
\end{minted}

\begin{verbatim}
[6.2832946]
\end{verbatim}

$k$'nin aþaðý yukarý doðru deðerde olduðunu görüyoruz. Tüm çözümü
grafikleyince beklenen sinüs eðrisini de göreceðiz, 

\begin{minted}[fontsize=\footnotesize]{python}
x_plot = np.linspace(0, 1, 100)
y_plot = sol.sol(x_plot)[0]
plt.plot(x_plot, y_plot)
plt.xlabel("x")
plt.ylabel("y")
plt.savefig('compscieng_app10boundary_04.png')
\end{minted}

\includegraphics[width=20em]{compscieng_app10boundary_04.png}

Bilinmeyen Sabit Durumlarý

Her TPBVP problemi üstte görülen yazýlýmlara direk, olduðu gibi aktarýlacak
durumda olmayabilir. Ama bu problemleri de bazý numaralar kullanarak
çözüm yazýlýmýnýn beklediði hale çevirebiliriz. 

Mesela çoðu sýnýr deðeri problemi bilinmeyen sabitler içerirler, ki çözüm
içi bu sabitlerin bilinmesi gereklidir. Bu tür problemler üstteki
yöntemlerle direk çözülemez. Ama bilinmeyen sabitleri de birer deðiþken
olarak kabul edersek, bu engelin etrafýndan dolaþabiliriz. Bu
``deðiþkenin'' ilk türevi tabii ki sýfýr olacaktýr, ve bu türevin sýfýra
eþit olma hali üzerinden sabiti diferansiyel denklem sistemimize dahil
edebiliriz. 

{\em Elastiklik} (elastica) problemi mekanik alanýnda standart bir problem
[3, sf. 221]. Bir ucu yere baðlý bir esnek çubuða diðer uçtan uygulanan
kuvvet ile nasýl büküldüðünü gösteriyor. Sabiti dahil etmeden ana sistem
þöyle,

$$
x' = \cos (\phi) 
$$

$$
y' = \sin (\phi) 
$$

$$
\phi' = \kappa
$$

$$
\kappa' = F \cos (\phi)
$$

Bilinmeyen sabit $F$. Sýnýr deðerleri,

$$
x(0) = 0
$$

$$
y(0) = 0
$$

$$
\kappa(0) = 0
$$

$$
y(0.5) = 0
$$

$$
\phi(0.5) = -\pi/2
$$

Görülen beþ tane sýnýr deðiþkeniyle aslýnda problemi tamamen tanýmlanmýþ
oluyor. Entegrasyondan ortaya çýkan dört tane sabit olacak, üstte beþ tane
deðer var. Hatta $F$'yi de bir sýnýr deðeri olarak dahil edince hala çözüm
için yeterli öðe elimizde oluyor. Yeni sýnýr deðeri

$$
F' = 0
$$

Dikkat, yani $F$'nin türevi her yerde sýfýr olmalý (çünkü sabit).

\begin{minted}[fontsize=\footnotesize]{python}
# x,y,\phi,\kappa, F
from scipy.integrate import solve_bvp

def fun(x, y):
    return np.vstack(( np.cos(y[2]),
                       np.sin(y[2]),
                       y[3],
                       y[4]*np.cos(y[2]),
                       np.zeros(x.shape[0]) ))

def bc(ya, yb):
    return np.array([ ya[0],
                      ya[1],
                      ya[3],
                      yb[1],
                      yb[2]+(np.pi/2) ])

x = np.linspace(0, 0.5, 400)
y = np.zeros((5, x.size))
sol = solve_bvp(fun, bc, x, y)
print (sol.y[4,0])
\end{minted}

\begin{verbatim}
-21.54910449259776
\end{verbatim}

$F$ sabitinin degeri ustte goruluyor. 

Dikkat edilirse \verb!fun! içinde $F$'ye sýfýr deðeri vermek için
\verb!np.zeros(x.shape[0])! deðeri tanýmlandý, yani bir sýfýr vektörü
tanýmlandý.

$y$ deðerlerini grafikleyelim,

\begin{minted}[fontsize=\footnotesize]{python}
plt.plot(x,sol.y[1])
plt.title('y')
plt.savefig('compscieng_app10boundary_05.png')
\end{minted}

\includegraphics[width=20em]{compscieng_app10boundary_05.png}



Kaynaklar

[1] Yang, {\em Applied Numerical Methods using Matlab}

[2] Scipy, {\em Scipy Reference, 0.18.1}

[3] Cash, {\em Solving Differential Equations in R}

\end{document}

