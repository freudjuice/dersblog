<h1>Ağ Akış Problemleri (Network flow problems)</h1>
<!DOCTYPE html>
<html>
  <head>
    <title>Ağ Akış Problemleri (Network flow problems)
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [["$","$"]]}
      });
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"],
        bcancel: ["Extension","cancel"],
        xcancel: ["Extension","cancel"],
        cancelto: ["Extension","cancel"]
      });
    });
    </script>
<script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full">
</script>
</head>

<p>Daha önce işlediğimiz bu konuyu biraz daha genişletelim [1]. Sailco adlı
hayali bir şirket düşünelim, bu şirket yelkenli tekne (sailbot)
üretiyor. Problem şöyle, önümüzdeki 4 ay içinde alttaki üretim sayısını
gerçekleştirmesi gerekiyor (müşteri talebi)</p>
<p>$$ 
\begin{array}{|c|c|c|c|c|}
\hline
\textrm{Ay} &amp; 1 &amp; 2 &amp; 3 &amp; 4 \\
\hline
\textrm{Üretilen tekne sayısı} &amp; 40 &amp; 60 &amp; 70 &amp; 25 \\
\hline
\end{array}
$$</p>
<p>Birinci ayda 40, ikinci ayda 60, vs.. Şirketin bir deposu da var, bitmiş
teknelerin teslim etmeden önce tutuldukları yer burası. 1. ayın başında bu
depoda 10 tane tekne var. Her ay kaç tane tekne (ve nasıl) üretileceğini
hesaplamam lazım, burada işçi turu ve depoda olanlar sayıyı etkiler tabii,
mesela bir ayda 10 tane üretmem gerekiyorsa ve depoda zaten 10 tane varsa,
hiç üretim yapmama gerek yok. Ama gelecekte çok fazla üretmem gerektiğini
biliyorsam ekstra yapıp onları depoda tutabilirim, ki sonra gönderebileyim.</p>
<p>İşçi kısıtlaması şöyle, normal işçiyle 400 lira / tekne üzerinden fazla
mesai ile 450 lira / tekne üzerinden üretim yapabilirim. Tek bir tekneyi
depoda tutmak 20 lira. Ayrıca normal işçi ile ayda sadece 40 tekne
yapabiliyorum, eğer o ayda daha fazla tekne yapmam gerekiyorsa fazla mesai
kullanmam şart.</p>
<p>Problem şöyle, öyle bir üretim ve depolama takvimi planla ki önümüzdeki 4
aydaki üretimi minimum masrafla yapabileyim. </p>
<p>Karar değişkenleri neler olacak? Görüyorum ki bu tür problemlerle uğraşan
bazı öğrenciler genelde az sayıda değişken kullanmaya meyilli, mesela "X
ayında üretilecek tekne sayısı" gibi, ve beklenti o ki formüller işin
gerisini halletsin. Yani mesela ilk ay bariz zaten, depoda 10 tane tekne
var, geri kalanını ilk ayda normal işçilere yaptırırım çünkü bu en ucuzu. O
zaman o ayda üretilen tekne sayısı değişkeni yeter, vs. Fakat göreceğiz ki
bu tür yaklaşımlar aslında işi daha zorlaştırıyor. Aslında işimize
yaramayabilecek ekstra değişkenler tanımlamak, sonra o değişkenleri
kısıtlayıp probleme uygun şekilde dahil etmek daha kolay.</p>
<p>Biz de böyle yapacağız. Bir sürü değişken; mesela X ayı için kaç tane
"normal işçi teknesi" üretilmesi gerektiği, yani bu sayı sadece normal
işçiler tarafından üretilecek tekneleri kontrol edecek, fazla mesai için
farklı olacak.. Her ay depoda kaç tekne tutulduğu ayrı sayılacak, her şey
bir değişken olacak. Belki bu değişkenlerden bazıları fuzuli, hatta başka
bir şeyi tekrar ediyor sanki, başka değişkenlerden türetilebilir gibi
geliyor, olsun, yine de ekstra değişkeni koyun, ama diğer yandan
aklınızdaki o kuralı probleme sınırlama olarak dahil edin. </p>
<p>Yani literaturde bu degiskenlere karar degiskenleri deniyor ama aslinda
onlarin direk karar verdigimiz seyler olmasina gerek yok. </p>
<p>Değişkenler şöyle,</p>
<p>$x_1,x_2,x_3,x_4$: her ayda normal işçilik ile üretilen tekne sayısı</p>
<p>$y_1,y_2,y_3,y_4$: her ayda fazla mesai ile üretilen tekne sayısı</p>
<p>$h_1,h_2,h_3,h_4,h_5$: her ay başında depoda olan tekne sayısı. 5 ay var
çünkü ay sonundaki sayıyı $h_5$ değişkeninde tutuyoruz. Tabii problemi iyi
anlayanlarımız farketmiştir ki bu değişkende sıfır değeri olmalı, tüm
tekneler gönderilmiş olmalı.</p>
<p>Parametreler</p>
<p>Bunlar değişken değil dikkat, dışarıdan tanımlanan parametreler. Başta
gördüğümü sayılar bunlar, her ay müşteriden gelen talep, </p>
<p>$d_1,d_2,d_3,d_4$: her ay için talep (demand). </p>
<p>Kisitlamalar</p>
<p>$0 \le x_i \le 40$, ki $i=1,2,3,4$: normal işçilikle üretilebilecek tekne
sayısı, çünkü üstte belirttik, o tür üretimin sınırı bu</p>
<p>$y_i \ge 0$: fazla mesai ile üretilebilecek tekne sayısı sınırsız. Tabii ki
negatif tekne üretilemez, o sebeple sıfırdan büyüklük var. </p>
<p>$h_i + x_i + y_i = d_i + h_{i+1}$: teknelerin muhafazası denklemi. Burada
diyoruz ki her ay başında depodaki tekneler artı normal ve fazla mesai
işçilik ile ürettiğim teknelerin toplamı, o aydaki talep ve sonraki aya
kalacak depodaki teknelerin toplamı ile aynı olmalı. </p>
<p>Ayrıca $h_1=10$ olduğunu biliyoruz.</p>
<p>Önceki noktayı tekrar vurgulamak gerekirse üstteki $h$ değişkenlerini belki
tanımlamam fuzuli, onları $h,d$'ler üzerinden de tanımlayabilirdim. Ama bu
şekilde yapmak çok daha açık. </p>
<p>[atlandi]</p>
<p>Bu problemin lineer program olduğunu görebiliyoruz, ama hiçbir ağ akışı
filan göstermedim. O zaman dersimizin başlığı niye ağ akışı? Çünkü bu
problemi bir ağ yapısı içinden akış olarak görmek te oldukca doğal. 
Ağdaki 1,2,3,4 düğümleri aylar olacak, ve tekneler o aylar içinden
"akıyorlar", eğer bir ay sonrasında depoya bir tekne koyuyorsak sanki o
tekne geleceğe doğru gönderiliyor, sonraki aya veriliyor, o sebeple aylar
arasındaki oklar $h_i$. </p>
<p><img alt="" src="func_90_nflow_01.png" /></p>
<p>Tabii tüm tekneler bir aydan ötekine akmıyor, müşterilerin (customers)
talebine göre o aydan onlara da belli sayıda tekne "akıyor", $d_i$ ile
gösterilenler. Her aya giren akış üretim, R ile gösterilen normal
işçilikle, OT ile gösterilen fazla mesai ile.  Bu resimle problemi bir ağ
akışı olarak göstermiş olduk.</p>
<p>Daha önce gördüğümüz muhafaza denklemi bu resimde daha bariz hale geldi,
çünkü bu resimle aslında şunu söylüyoruz, her ay düğümüne giren akışlar
çıkış akışlarına eşit olmalı. Bu hem kuvvetli bir ifade ama aynı anda
bariz. Düğümler içinde bir şey tutmamalı, oradan sadece akış var. </p>
<p>Bugün genel olarak göreceğimiz konu minimum bedel akış problemleri olacak,
ki üstteki problem bunun bir örneği. Pek çok optimizasyon problemi yönlü
bir ağ üzerindeki akış olarak görülebiliyor. </p>
<p>Alttaki gibi bir ağ düşünelim,</p>
<p><img alt="" src="func_90_nflow_02.png" /></p>
<p>8 tane düğümü var, bazı kenarları var. Bu ağdaki karar değişkenleri her
kenardaki akış. Dikkat, karar değişkeni düğümde değil, kenarda. Bulmak
istediğimiz bu akış çünkü, bilahere karar değişkenleri. Bu kenarların her
birinde ne kadar akış var? </p>
<p>Her kenardaki akışın bir bedeli olabilir, ayrıca her kenarın bir kapasite
sınırlaması olabilir (bedeli ne olursa olsun üzerine çıkılamayacak bir eşik
değeri). Bedel örneği olarakl mesela bir kenar 2 lira/birimlik olabilir
diğeri 10 lira/birim bedelinde olabilir. O zaman ilk kenardan 5 birim
göndermek istersem bunun bana bedeli 10 lira ikincisinden gondermek
istersem 50 lira olacak. Her kenarın akış bedeli, kapasitesi bizim
dışarıdan bir parametre ile tanımladığımız bir şey olacak tabii
ki. Kapasitenin illa sınırlanmış olması gerekmez, sınırsız da olabilir.</p>
<p>Her düğüm bir akış kaynağı (source) da olabilir, yani akışı kendi içinden
"doğuruyor" olabilir. Bazı düğümler akışı yutuyor olabilir, onlara akış
gelir ve yokolur, bu düğümlere alıcı (sink) diyebiliriz. O zaman önceki
gördüğümüz sadece aktarıcı düğümlere ek olarak bu iki tip düğümü de
kullanabiliriz. Üstteki resimde en soldaki iki düğüm kaynak gibi duruyor,
oradan sadece çıkan akış görüyoruz. En sağdaki ise alıcı, ona akış sadece
giriyor. </p>
<p>Optimizasyon probleminin sorduğu soru şu olacak, "en minimum bedelli akış
hangisi?". Pek çok türlü akış olabilir, bizim aradığımız bedeli en az
olan. Bugün göreceğimiz tüm problemler birer minimum bedelli akış problemi
olarak formülize edilebilir. İlk önce en başta gördüğümüz problemi ağ
yapısına tercüme edeceğiz, sonra diğer göreceğimiz problemlerin birer LP
olup olmadığına bakacağız. </p>
<p>Düğümleri numaralandıralım,</p>
<p><img alt="" src="func_90_nflow_03.png" /></p>
<p>Her akışı, karar değişkenini $x_{ij}$ olarak gösterebiliriz, ki
$(i,j) \in \varepsilon$, 1'den 3'e akış $x_{13}$ olacak. Akış bedeli
$c_{ij}$. Toplam bedel her akış çarpı o akışın bedeli toplanmış
hali. Kapasite sınırları $p_{ij} \le x_{ij} \le q_{ij}$ ile gösterilebilir,
her kenarın bir alt bir de üst sınırı olabilir ($p_{ij}$ çoğu problem için
sıfırdır). Muhafaza denklemi, her düğüm $k$ için [1, 26:22]</p>
<p>$$
\sum_{j \in N} x_{kj} - \sum_{i \in N} x_{ik} = b_k, \quad \forall k \in N
$$</p>
<p>Toplam bedel</p>
<p>$$
\sum_{(i,j) \in \varepsilon } c_{ij} x_{ij}
$$</p>
<p>Üstteki ifade üzerinden toplam bedeli minimize eden akışı bulabiliriz. </p>
<p>Bu bir lineer program değil mi? Bedel lineer, lineer eşitlik, eşitsizlik
sınırlamaları. Evet bu bir LP. </p>
<p>Formel ve öz bir şekilde yazmak gerekirse, </p>
<p>$$
\min_{x_{ij} \in \mathbb{R}} \sum_{(i,j) \in \varepsilon } c_{ij} x_{ij}
\quad \textrm{öyle ki}
$$
$$
\sum_{j \in N} x_{kj} - \sum_{i \in N} x_{ik} = b_k, \quad \forall k \in N
$$
$$
p_{ij} \le x_{ij} \le q_{ij}
$$</p>
<p>Şimdi muhafaza kısıtlamasına dönmek istiyorum, aslında bu formülü matris
formunda yazmanın çok güzel bir yolu var. </p>
<p><img alt="" src="func_90_nflow_04.png" /></p>
<p>Matrise $A$ sembolü verilir çoğunlukla ve ona oluş, geliş (incidence)
matrisi denir.  Örnek olarak sonuncu satıra bakalım, bu satır 8'inci düğüme
olanları gösteriyor, $-x_{68}-x_{78}$ hesabı var, eksi işareti düğüme giriş
göstergesi, ve sonuç $b_8$'e eşit. </p>
<p>$A$'da sadece 0, -1 ve +1 değerleri vardır ve eldeki düğüm kadar satırı
vardır, ve eldeki kenar kadar kolonu vardır. Dikkat geliş matrisi sadece ağ
yapısını kodlar, kenarlardan giden akış miktarı hala $x_{ij}$ değerlerinin
kendisinde. </p>
<p>Eğer gereken yerde vektörler de kullanırsak en öz haliyle model şöyle,</p>
<p>$$
\min_{x \in \mathbb{R}^{|\varepsilon|}} c^T x, \quad \textrm{oyle ki}
$$
$$
Ax = b
$$
$$
p \le x \le q
$$</p>
<p>Denge konusundan bahsedelim, minimum bedelli akış probleminin "dengeli"
olması durumu var. Üstteki örnekteki gibi bir problemi düşünürsek, bazı
düğümle kaynak, bazıları alıcı, tüm düğümlerdeki girenler çıkanlar sıfıra
toplanır, o zaman tüm kaynakların toplamının da tüm talebin toplamına eşit
olması beklenir. Çünkü ekstra kaynak varsa mesela tüm denklemleri tatmin
etmek mümkün olmaz. Bunu ispatlayabiliriz, geliş matrisinin bir özelliği
tüm kolonlarının toplamının sıfır olması, yani $1^T A = 0$. Ayrıca $Ax =
b$'nin de doğru olduğunu biliyoruz çünkü çözeceğimiz sistemin bir
kısıtlaması bu formül. O zaman alttaki de doğru olmalı, </p>
<p>$$
1^T A x = 1^T b = 0
$$</p>
<p>Eşitliğin sağındaki $1^T b$ tüm $b$ öğelerinin toplamı demek, yani</p>
<p>$$
\sum _{i \in N} b_i = 0
$$</p>
<p>olmalı. Demek ki tüm arz tüm talebe eşit olacak. O zaman size $b$'sı sıfıra
toplanmayan bir minimum bedel akış problemi verirsem bu problem olurlu
olmayacaktır. Toplam sıfır ise bu probleme "dengeli problem"
deniyor. Tabii dengeli bir modelin de illa olurlu olması şart değil, mesela
öyle kapasite sınırlamaları getirebilirsiniz ki olurluluk mümkün olmaz, ama
denge yoksa problem kesinlikle olurlu değildir.</p>
<p>Ama bazen dengesiz problemleri de ufak değişiklikler ile çözmek mümkün
oluyor, mesela bazı $=$'leri $\le$ yaparak, ki bunun karşılığı ağa bir
kukla (dummy) düğüm eklemek olabilir .. Ya da pay bırakma (slack)
değişkenleri ekleyip bazı eşitsizlikleri eşitlikge çevirerek..</p>
<p>Örnek Alanlar </p>
<p>Ne kadar çok problemin minimum akış problemi olabildiği şaşırtıcı
olabilir. </p>
<ul>
<li>nakliyat problemleri  (transportation)</li>
<li>görev verme / atama problemleri (assignment)</li>
<li>aktarmalı gemi nakliyatı (transshipment)</li>
<li>en kısa yol problemleri (shortest path)</li>
<li>maksimum akış problemleri (max-flow)</li>
</ul>
<p>Nakliyat</p>
<p>Hedef belli bir mali birkaç kaynak noktasından farklı varış noktalarına
ulaştırmak. Kaynaklar bir sürü depo, ambar olabilir, varış noktası farklı
müşteriler olabilir, ürünlerin depodan müşterilere gitmesi gerekiyor. Ama
mesela ambar 1'den müşteri 2'ye gönderim olabilir, ya da ambar 4'ten aynı
müşteriye.. ? Karar verilmesi gerekiyor, her müşterinin kendine göre talebi
var, her nakliyat yolunun farklı bedeli var, yolların kapasite limitleri
var, depoların arz limitleri var, bu problem en az bedelli talebi tatmin
eden nakliyat kararını verecek.</p>
<p><img alt="" src="func_90_nflow_05.png" /></p>
<p>Örnek şöyle olabilir, Millco'nun (hayali bir şirket) üç tane bakır işleme
fabrikası var, üç tane de maden bölgesi var. Nakliyatın bedeli km başına 2
lira. Madenler ve fabrikalar arası mesafeler alttaki gibi, o zaman her
talebi tatmin edip en az nakliyat masrafı için hangi nakliyat planı takip
edilmeli?</p>
<p>$$ 
\begin{array}{|c|c|c|c|P{3cm}|}
\hline
Maden &amp; \textrm{Fabrika 1} &amp; 
\textrm{Fabrika 2} &amp; 
\textrm{Fabrika 3} &amp; 
\textrm{Maden başına günlük maksimum kamyon sevkiyatı}\\
\hline
1 &amp; 8 &amp; 15 &amp; 50 &amp; 20 \\
\hline
2 &amp; 10 &amp; 17 &amp; 20 &amp; 30 \\
\hline
3 &amp; 30 &amp; 26 &amp; 15 &amp; 45 \\
\hline
Fabrika talebi &amp; 30 &amp; 35 &amp; 30 &amp; \\
\hline
\end{array}
$$</p>
<p>İlk kontrol edebileceğimiz faktör acaba ağ dengeli mi? Tüm arz toplamı tüm
talep toplamı ile aynı mı? Evet. O zaman üstteki çözülebilecek bir
problem olabilir. Düğümleri $\left[\begin{array}{cccccc} 1&amp;2&amp;3&amp;A&amp;B&amp;C \end{array}\right]$
olarak düzenleyeyim, kaynaklar bir blok olarak önce, alıcılar sonra. Geliş
matrisi altta [1, 43:55],</p>
<p>Bu tamamen bağlantılı (full connected) bir çiziti temsil ediyor, yani
herhangi bir maden düğümünden herhangi bir fabrika düğümüne gitmenin yolu
var. Çözüm</p>
<pre><code>   A  B  C
1 20  0  0 
2 10 20  0
3 0  15  30
</code></pre>

<p>Biz de <code>linprog</code> ile kontrol edelim,</p>
<pre><code class="python">A = [[ 1,  1,  1,  0,  0,  0,  0,  0,  0],
      [0,  0,  0,  1,  1,  1,  0,  0,  0],
      [0,  0,  0,  0,  0,  0,  1,  1,  1],
      [-1, 0,  0, -1,  0,  0, -1,  0,  0],
      [0, -1,  0,  0, -1,  0,  0, -1,  0],
      [0,  0, -1,  0,  0, -1,  0,  0, -1]]

b = [ 20, 30, 45, -30, -35, -30 ]

c = [ 8, 15, 50, 10, 17, 20, 30, 26, 15]

A = np.array(A); b = np.array(b); c = np.array(c)

from scipy.optimize import linprog

res = linprog(-c, A_eq=A, b_eq=b)
print (np.round(res.x))
</code></pre>

<pre><code>[ 0.  0. 20.  0. 20. 10. 30. 15.  0.]
</code></pre>

<p>Bu örnekteki $b$'de hiç sıfır öğesi yok, niye? Çünkü bu ağ yapısında talep
ve arz tüm düğümlerde tanımlı, yani her düğüm ya bir kaynak ya da
alıcı. Böyle olmayabilirdi, arada geçiş düğümleri olsaydı onlar üzerinde
muhafaza mantığı sebebiyle sıfır tanımı yapmak gerekebilirdi. </p>
<p>Atama (Assignment Problems)</p>
<p>Bu tür problemler nakliyat problemine benzer, ama n tane çalışanım n tane
yapılacak isim var. Amaç her n kişiye birer görev vermek. Diyelim ki her
çalışanın her görev için farklı tercihi var, mesela ev işlerinde bulaşık,
çöp atmak, duvar boyamak için A, B kişileri 1 ile 10 ara]sında tercih
belirtmiş olabilir. Amaç her işi bir kişiye atamak, öyle ki tüm işler
yapılsın aynı anda herkes olabildiği kadar mutlu olsun. </p>
<p>Bu problem de nakliyat problemi gibi! Ama şimdi akış 1 ya da 0. Her kaynağa
1 giriyor, her alıcıdan 1 çıkıyor. Kenarlar üzerinde hiç kısıtlama yok. </p>
<p>Ama bazılarımız sorabilir, 0.2 insanı bir göreve, 0.8 insani diğerine
gönderme gibi bir sonuç ta istemem, bir tür tam sayı kısıtlaması da olmalı
bu problemde, yani her kenardaki akış ya 0 ya da 1 olmalı. Bu tür
kısıtlamaları ileride işleyeceğiz. </p>
<p>Örnek görelim, bir yüzücü antrenörüyuz diyelim, eğittiğimiz 5 yüzücü
arasından bayrak yarışı için seçme yapmamiz gerekiyor. Bayrak yarışında her
gidiş gelişte ardı ardına dört ayrı stil gerekiyor, dört farklı yüzücü bu
stillerde yarışabiliyor, bir gidip geliş sonrası bir yüzücü diğerine
bayrağı aktarıyor. Stiller sırtüstü (backstroke), kurbağalama
(breaststroke), kelebek (butterfly), serbest stil (freestyle). Her stil bir
turda kullanılınca toplam tüm stilleri en çabuk kullanmış olan takım
kazanıyor. Elimizdeki yüzücülerin bu her alandaki geçmişteki zamanlarını
biliyoruz, bu o yüzücülerin her stildeki kuvvetleri bir bakıma,</p>
<p><img alt="" src="func_90_nflow_07.png" /></p>
<p>Şu mümkün; bir süper yüzücümüz olabilir her stilde en iyi o'dur. Ama bu tek
adamı 4 kez, her stilde kullanamayız, her stil için farklı birini seçmemiz
lazım. Bu adamı tabii ki bir stil için kullanmak isteriz, ama hangisi için?
Optimal sonuç için bir dengeleme yapmak lazım. </p>
<p>Bu bir atama / görevlendirme problemi işte, her yüzüs stilini birine
"atıyorum". Bu arada elimizde 4 stil ama 5 yüzücü var, yani bir yüzücü
görevsiz kalacak.</p>
<p>Üstteki resimde kırmızı renk yapılan tercihi belirtiyor [1, 54:08]. </p>
<p>Aktarmalı gemi nakliyatı</p>
<p>Bu tür nakliyat problemlerinde bir mali kaynaktan alıcıya direk göndermeye
ek olarak arada bir depoda da tutmamız mümkün, bu durum tabii ki lojistik
planlamada değişiklikler getirebilir. Amazon gibi şirketler bunu sürekli
yapıyor mesela, bir ürünü önce büyük bir antrepoya gönderiyorlar, oradan
başka bir yere aktarma yapıyorlar. </p>
<p><img alt="" src="func_90_nflow_08.png" /></p>
<p>Orta kısımda sarımsı renkle görülen aktarma noktaları. Normal aktarma
problemlerinde olduğu gibi kaynak, alıcı var, arz ve talep sınırları var,
kenarlarda sınırlar olabilir, aktarma noktaları için giren ve çıkan
birbirini dengelemeli, yani muhafaza denklemi onlar için geçerli [1,
56:00]. Aslında başta gördüğümüz Sailco problemi bir aktarmalı nakliyat
problemi.. Depo var, üretici, alıcı var..</p>
<p>[devam edecek]</p>
<p>Kaynaklar</p>
<p>[1] Lessard, <em>Introduction to Optimization, CS/ECE/ISyE 524, Lecture 5</em>, 
    University of Wisconsin-Madison,
    <a href="https://laurentlessard.com/teaching/524-intro-to-optimization">https://laurentlessard.com/teaching/524-intro-to-optimization</a></p>