<h1>Newton'un Metodu (Newton's Method)</h1>
<!DOCTYPE html>
<html>
  <head>
    <title>Newton'un Metodu (Newton's Method)
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [["$","$"]]}
      });
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"],
        bcancel: ["Extension","cancel"],
        xcancel: ["Extension","cancel"],
        cancelto: ["Extension","cancel"]
      });
    });
    </script>
<script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full">
</script>
</head>

<p>Bu notlar [2] dersinden alındı.</p>
<p>Newton birazdan bahsedeceğimiz yöntemi tek boyutlu problemler için
kullandı. Rhapson adlı bilimci yöntemi çok boyutlu problemler için
genişletti. Biz bu yönteme optimizasyon çerçevesinde bakacağız.  Konunun
tarihinden biraz bahsetmek istiyorum, bu dersi öğretmeye başladığımda 1986
senesiydi, Newton'un metodunu nasıl gördüğümüz o zamandan beri değişime
uğradı. NM o zamanlar son başvurulan metot diye öğretiliyordu, çünkü metodu
kullanmak için "büyük" bir denklem sistemi çözmek gerekiyordu, 500 x 500
bir sistem mesela. Bugüne gelelim artık NM ilk başvurulan metot haline
geldi, 50,000 x 50,000 boyutlarında bir sistem çözmek "yetiyor" ve böyle
bir sistem artık idare edilebilen bir boyut haline geldi. Yani hesapsal
kapasite NM'in optimizasyon alanında oynadığı rolü tamamen değiştirdi.</p>
<p>Diğer bir faktör ileride öğreneceğimiz iç nokta (interior-point)
metotlarının Newton'un metodunu kullanıyor olmaları. İç nokta metotları
icbukey optimizayonda çok popüler, onlar için NM gerekiyor, bu da NM'in
popülaritesini arttırıyor.</p>
<p>NM nedir? Elimde bir kısıtlanmamış (unconstrained) problemim var diyelim,</p>
<p>$$
\min f(x), \quad \textrm{ öyle ki } \quad x \in X = \mathbb{R}^n
$$</p>
<p>Bir Taylor açılımı yapabilirim,</p>
<p>$$
f(x) \approx 
f(\bar{x}) + 
\nabla f(\bar{x})^T (x-\bar{x}) + 
\frac{1}{2} (x-\bar{x})^T H (x-\bar{x}) 
$$</p>
<p>ki $H$ Hessian matrisi. Üstteki formüle $h(x)$ diyelim. Böylece bir karesel
model ortaya çıkartmış oldum, formülün sağ tarafındaki çarpım onu karesel
yapıyor, ve şimdi onu kesin olarak çözmek istiyorum. Bunu nasıl yaparım?
Formülün gradyanını sıfıra eşitleyebilirim. Üstteki fonksiyonun $x$'teki
gradyanı nedir? </p>
<p>Gradyanı $x$'e göre aldığımızı unutmayalım, $h(x)$'in ikinci terimi
$\nabla f(\bar{x})^T$ bir sabit sayı, ikinci gradyan alınırken sıfırlanır,
ve tüm ikinci terim sıfırlanır. Üçüncü terimin gradyanını almak bir nevi
$\frac{\partial (x^TAx)}{\partial x} $ almak gibi [1], $H$ belli bir
noktadaki ikinci türev matrisi olduğu için $A$ gibi bir sabit matris kabul
edilebilir, $A$ simetrik olunca gradyan $2Ax$ sonucunu veriyordu, $H$
simetrik, o zaman üçüncü terimde $H$ kalır, 2 ve $1/2$ birbirini iptal
eder, sonuç</p>
<p>$$
\nabla h(\bar{x}) = \nabla f(\bar{x}) + H(\bar{x})(x-\bar{x}) 
$$</p>
<p>İki üstteki karesel yaklaşıksal ifadenin gradyanı bu işte. Onu sıfıra
eşitleriz ve çözeriz. $H$ tersi alinabilir bir matristir, o zaman </p>
<p>$$
\nabla h(\bar{x}) = \nabla f(\bar{x}) + H(\bar{x})(x-\bar{x}) = 0
$$</p>
<p>$$
(x-\bar{x}) = -H^{-1} \nabla f(\bar{x})
$$</p>
<p>Üstteki ifadeye $d$ diyebilirim, ve bu $d$ benim Newton yönüm olarak
görülebilir, yön derken optimizasyon bağlamında minimuma giden yön. </p>
<p>Bu bizi gayet basit 4 adımlık bir algoritmaya taşıyor,</p>
<p>0) $x^0$ verildi, bu başlangıç noktası, $k = 0$ yap.</p>
<p>1) $d^k = -H(x^k)^{-1} \nabla f(x^k)$. Eğer $d^k=0$ ise dur.</p>
<p>2) $\alpha^k = 1$ adım boyu seç</p>
<p>3) $x^{k+1} = x^k + \alpha^k d^k$, $k = k + 1$ yap, ve 1. adıma geri dön.</p>
<p>Bu metodun önemli bir özelliğinin her adımda sadece bir lineer sistemi
çözmek olduğunu görüyoruz (tersini alma işlemi). Bir lineer sistemi çözmek
kolay midir? Sisteme göre değişir, 100 x 100 sistem, problem yok. 10,000 x
10,000 yoğun bir sistem var ise (seyrek matrisle temsil edilen lineer
sisteme nazaran) işimiz daha zor olacaktır. Bu tür sistemlerde Gaussian
eliminasyon işlemeyebilir, bir tür özyineli metot gerekli. Demek istediğim
Newton yönteminin darboğazı bir lineer denklem sistemini her seferinde
sıfırdan başlayarak çözmek, ve bunu her döngüde yapmak.</p>
<p>Fakat bu çözümün bize pek çok şey kazandırdığını da görmek lazım;
bahsedilen sistemi çözmek bize pek çok bilgi kazandırıyor çünkü çözülen
problem içinde 1. ve 2. türev bilgisi var. Bu bilgi minimizasyon açısından
daha akıllıca adım atılabilmesini sağlıyor. </p>
<p>Metot Hessian'ın her adımda tersi alınabilir olduğunu farzediyor, bu her
zaman doğru olmayabilir. O sebeple bunun doğru olduğu türden problemler ile
uğraşacağız, ya da Hessian'ın tersi alınabilir olmasını sağlayan
mekanizmaları göreceğiz. $H$'nin özünü bozmadan değiştirerek tersi
alınabilir olmasını sağlayan yöntemler var. </p>
<p>Ayrıca hedef her adımda fonksiyonunu oluşturduğumda bu fonksiyonun azalma
garantisi yok. Öyle ya akıllı bir algoritmanin her adımda hedef
fonksiyonumu daha iyiye götürdüğümü düşünebilirdim, ama şu anda kadar
gördüklerimiz ışığında, bunun garantisi yok. Bu konuya sonra değineceğiz. </p>
<p>Bir diğer nokta 2. adımın çizgi arama ile genişletilebilmesi [atlandı]</p>
<p>NY'nin en çekici tarafı, eğer yakınsama (convergence) mümkün ise bu
yakınsamanın çok hızlı bir şekilde olması, ki bu iyi. Bu konuya gelmeden
metodun bazı ek özelliklerini görelim.</p>
<p>Terminoloji: bir matrise SPD denir eger matris simetrik, pozitif kesin ise
(simetric positive-definite). </p>
<p>Teklif (Proposition) 1: </p>
<p>Eğer $H(x)$ SPD ise $d \ne 0$, o zaman $d$ $\bar{x}$ noktasında bir iniş
yönüne işaret eder. İniş yönü olması demek, eğer makul ufak bir adım
çerçevesinde gidilen noktada $f$'in değerinin o an olduğumuz noktadan daha
az olması demektir.</p>
<p>Nasıl ispatlarım? Önceki dersten hatırlarsak, eğer yönüm gradyan ile
negatif iç çarpıma sahip ise, o zaman yönüm kesinlikle bir iniş yönüydü.</p>
<p>Teori </p>
<p>Diyelim ki $f(x)$ fonksiyonu $\bar{x}$ noktasında türevi alınabilir halde
[2, sf. 9]. Eğer elimizde $\nabla f(\bar{x})^T d &lt; 0$ sonucunu veren bir
$d$ vektörü var ise, öyle ki her yeterince küçük $\lambda &gt; 0$ için
$f(\bar{x}+\lambda d) &lt; f(\bar{x})$ olacak şekilde, o zaman $d$ bir iniş
yönüdür.</p>
<p>İspat </p>
<p>Taylor açılımı ile yönsel türev tanımına bakarsak,</p>
<p>$$
f(\bar{x} + \lambda d ) = 
f(\bar{x}) + \lambda \nabla f(\bar{x})^T d + 
\lambda ||d|| \alpha(\bar{x},\lambda d)
$$</p>
<p>öyle ki $\alpha(\bar{x},\lambda d) \to 0$, $\lambda \to 0$ olurken. Not:
Norm içeren üçüncü terimdeki $\lambda ||d|| \alpha(\bar{x},\lambda d)$
ifadesi Taylor serisinin artıklı tanımından geliyor. Detaylar için [3,
sf. 360]'a bakılabilir.</p>
<p>Üstteki ifadeyi tekrar düzenlersek,</p>
<p>$$
\frac{f(\bar{x} + \lambda d) - f(\bar{x})}{\lambda} = 
\nabla f(\bar{x})^T + ||d||\alpha(\bar{x},\lambda d)
$$</p>
<p>$\nabla f(\bar{x})^T d &lt; 0$ olduğuna göre (aradığımız şart bu) o zaman, ve
$\alpha(\bar{x},\lambda d) \to 0$, $\lambda \to 0$ iken, her yeterince
küçük $\lambda &gt; 0$ için $f(\bar{x} + \lambda d)-f(\bar{x}) &lt; 0$ olmalıdır,
yani her hangi bir yönde atılan adım bir önceki $f$ değerinden bizi daha
ufak bir $f$ değerine götürmelidir. </p>
<p>Ana Teklif'e dönelim. Newton adımınıdaki SPD $H$ için $0 &lt; d^T \nabla f$
olduğunu göstermemiz lazım (ki böylece iniş yönü olduğunü ispatlayabilelim,
bir önceki teori),</p>
<p>$$
d = -H^{-1} \nabla f(\bar{x})
$$</p>
<p>demiştik, her iki tarafı $\nabla f(x)$ ile çarpalım,</p>
<p>$$
d \nabla f(x) = -\nabla f(x) H^{-1} \nabla f(x) 
$$</p>
<p>Eşitliğin sağ tarafındaki ifade hangi şartlarda eksi olur? Eğer $H$ matrisi
pozitif kesin ise değil mi? Genel matrislerden hatırlarsak, matris $A$ ve
bir vektör için $v$ eğer $A$ pozitif kesin ise $v^TAv &gt; 0$. Daha önce
$H$'nin pozitif kesin olduğunu söylemiştik, o zaman bir şekilde eğer $H$
pozitif kesin olmasının sadece ve sadece $H$'nin tersinin pozitif kesin
olmasına bağlı olduğuna gösterebilirsem amacıma ulaşabilirim.</p>
<p>Bunu yapmak aslında pek zor değil. Biliyorum ki $H(x)$ SPD. Simdi herhangi
bir vektor $v$ icin </p>
<p>$$
0 &lt; v^T H(x)^{-1}v
$$</p>
<p>ifadeyi şöyle genişletelim, $H(x)H(x)^{-1}$ eklemek hiçbir şeyi değiştirmez
çünkü bu çarpım birim matristir, </p>
<p>$$
v^T H(x)^{-1}v = v^T H(x)^{-1} H(x)H(x)^{-1} v &gt; 0
$$</p>
<p>Genişlemiş ifadenin harfiyen pozitif olduğunu biliyorum, iki üstteki
tanımdan. Ama şimdi üstteki ifadeye farklı bir şekilde bakarsak,</p>
<p>$$
v^T H(x)^{-1}v = \underbrace{v^TH(x)^{-1}} H(x) \underbrace{H(x)^{-1} v} &gt; 0
$$</p>
<p>İşaretlenen bölümlerin birer vektör olduğunu görebiliriz, bu durumda
$v^TAv &gt; 0$ pozitif kesinlik formülü farklı bir $v$ için hala geçerlidir, o
zaman ortadaki $A$, bu durumda $H(x)$ pozitif kesin olmalıdır. </p>
<p>Örnek 1</p>
<p>$f(x) = 7x - \ln(x)$ olsun. O zaman $\nabla f(x) = 7 - \frac{1}{x}$ ve
$H(x) = f"(x) = \frac{1}{x^2}$. Bu fonksiyonun özgün global minimumunun
$x^* = 1/7 = 1.428..$ olduğunu kontrol etmek zor değil. $x$ noktasındaki
Newton yönü</p>
<p>$$
d = -H(x)^{-1} \nabla f(x) = -\frac{f'(x)}{f"(x)} = 
-x^2 \left( 7 - \frac{1}{x}  \right)=
x - 7x^2
$$</p>
<p>Newton yöntemi ${ x^k }$ serisini üretecek, öyle ki</p>
<p>$$
x^{k+1} = x^k + ( x^k - 7(x^k)^2  ) = 2x^k - 7(x^k)^2
$$</p>
<p>Altta farklı başlangıç noktalarına göre üretilen serileri
görüyoruz. Yakınsamanın hangi değere doğru olduğu bariz, ve global minimum
da o değer zaten. </p>
<pre><code class="python">import pandas as pd
pd.set_option('display.notebook_repr_html', False)
pd.set_option('display.max_columns', 20)
pd.set_option('display.max_rows', 30) 
pd.set_option('display.width', 82) 
pd.set_option('precision', 6)
</code></pre>

<pre><code class="python">df = pd.DataFrame(index=np.arange(11))

def calculate_newton_ex1(x):
    arr = []
    for i in range(11):
        arr.append(x)
        x = 2*x - 7*x**2
        if (x &gt; 1e100):  x = np.inf
        if (x &lt; -1e100):  x = -np.inf
    return arr

df['1'] = calculate_newton_ex1(1.0)
df['2'] = calculate_newton_ex1(0.0)
df['3'] = calculate_newton_ex1(0.1)
df['4'] = calculate_newton_ex1(0.01)

print (df)    
</code></pre>

<pre><code>               1    2         3         4
0   1.000000e+00  0.0  0.100000  0.010000
1  -5.000000e+00  0.0  0.130000  0.019300
2  -1.850000e+02  0.0  0.141700  0.035993
3  -2.399450e+05  0.0  0.142848  0.062917
4  -4.030157e+11  0.0  0.142857  0.098124
5  -1.136952e+24  0.0  0.142857  0.128850
6  -9.048612e+48  0.0  0.142857  0.141484
7  -5.731417e+98  0.0  0.142857  0.142844
8           -inf  0.0  0.142857  0.142857
9           -inf  0.0  0.142857  0.142857
10          -inf  0.0  0.142857  0.142857
</code></pre>

<p>Örnek 2</p>
<p>Bu örnekte iki değişkenli bir fonksiyon görelim. Global minimum
$(1/3,1/3)$. Bakalım bu değeri bulabilecek miyiz?</p>
<p>$f(x) = -\ln( 1 - x_1 - x_2) - \ln x_1 - \ln x_2$</p>
<p>$$
\nabla f(x) = 
\left[\begin{array}{r}
\frac{1}{1-x_1-x_2} - \frac{1}{x_1} \\
\frac{1}{1-x_1-x_2} - \frac{1}{x_2} 
\end{array}\right]
$$</p>
<p>$$
H(x) = 
\left[\begin{array}{rr}
(\frac{1}{1-x_1-x_2})^2 - (\frac{1}{x_1})^2 &amp; (\frac{1}{1-x_1-x_2} )^2 \\
(\frac{1}{1-x_1-x_2} )^2 &amp; (\frac{1}{1-x_1-x_2})^2 - (\frac{1}{x_2})^2
\end{array}\right]
$$</p>
<pre><code class="python">import numpy.linalg as lin
df = pd.DataFrame(index=np.arange(11))

def calculate_newton_ex2(x):    
    arr = []
    for i in range(8):
        arr.append(x)
        x1,x2 = x[0],x[1]    
        H = [[(1.0/(1.0-x1-x2))**2 + (1.0/x1)**2.0, (1.0/(1.0-x1-x2))**2.0],
             [(1.0/(1.0-x1-x2))**2, (1.0/(1.0-x1-x2))**2.0 + (1.0/x2)**2.0]]
        H = np.array(H)

        Df = [[1.0/(1.0-x1-x2) - (1.0/x1)], [1.0/(1.0-x1-x2)-(1.0/x2)]]
        Df = np.array(Df)

        d = np.dot(-lin.inv(H),Df)
        x = x + d.flatten()

    return np.array(arr)

res = calculate_newton_ex2([0.85,0.05])
print (res)
</code></pre>

<pre><code>[[0.85  0.05 ]
 [0.717 0.097]
 [0.513 0.176]
 [0.352 0.273]
 [0.338 0.326]
 [0.333 0.333]
 [0.333 0.333]
 [0.333 0.333]]
</code></pre>

<p>54:37</p>
<p>[devam edecek]</p>
<p>Kaynaklar </p>
<p>[1] Bayramlı, Çok Boyutlu Calculus, <em>Vektör Calculus, Kurallar, Matris Türevleri</em></p>
<p>[2] Freund, <em>MIT OCW Nonlinear Programming Lecture</em>,
    <a href="https://ocw.mit.edu/courses/sloan-school-of-management/15-084j-nonlinear-programming-spring-2004/">https://ocw.mit.edu/courses/sloan-school-of-management/15-084j-nonlinear-programming-spring-2004/</a></p>
<p>[3] Miller, <em>Numerical Analysis for Scientists and Engineers</em></p>