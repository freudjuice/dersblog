<h1>Dağlar Arasında En Optimal Yürüyüş Yolu Bulmak</h1>
<!DOCTYPE html>
<html>
  <head>
    <title>Dağlar Arasında En Optimal Yürüyüş Yolu Bulmak
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [["$","$"]]}
      });
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"],
        bcancel: ["Extension","cancel"],
        xcancel: ["Extension","cancel"],
        cancelto: ["Extension","cancel"]
      });
    });
    </script>
<script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full">
</script>
</head>

<p>Elimizde bir alan içindeki yükseklikleri veren bir fonksiyon $f(x,y)$
olduğunu düşünelim. Acaba verili bir başlangıç ve bitiş noktası arasındaki
en "rahat" gidiş yolunu nasıl buluruz? </p>
<p>Bu problemi bir çizgi entegral hesabına çevirebiliriz. Bir skalar alan
üzerinden giden herhangi bir parametrize eğrinin altındaki alanı
hesaplamayı biliyoruz [2]. Ayrıca istediğimiz derecede polinom parametrize
eğrileri nasıl yaratacağımızı biliyoruz. Bu fikirleri bir araya koyarsak,
geriye kalan bir optimizasyon problemidir. Çünkü en rahat yol, "toplam
yüksekliği en az olan yol" olarak görülebilir, ve burada çizgi entegrali
faydalı olur.</p>
<p>Önce yükseklikleri ve eğrileri iki örnek üzerinde görelim,</p>
<pre><code class="python">from mpl_toolkits.mplot3d import Axes3D
from scipy.spatial.distance import cdist
from matplotlib import cm

def gfunc(x, y):
    s1 = 2.2; x1 = 2.0; y1 = 2.0
    g1 = np.exp( -4 *np.log(2) * ((x-x1)**2+(y-y1)**2) / s1**2)
    return g1 

def plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4):

    D = 50
    x = np.linspace(0,5,D)
    y = np.linspace(0,5,D)
    xx,yy = np.meshgrid(x,y)
    zz = gfunc(xx,yy)

    fig = plt.figure()
    ax = fig.gca(projection='3d')
    ax.set_xlim(0,5)
    ax.set_ylim(0,5)
    surf = ax.plot_wireframe(xx, yy, zz,rstride=10, cstride=10)

    t = np.linspace(0,1.0,100)

    x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
    y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4

    ax.plot3D(x, y, gfunc(x,y),'r.')

# 1. gidis yolunun tanimi, uzun yoldan dolanarak gidiyor
a1,a2,a3 = 1.5, 8.1, 4.0
b1,b2,b3 = 0.3, 0.4, 23.3
a0,b0=(1.0,1.0)
ex,ey=(0.3,4.0)
a4 = ex - a0 - (a1+a2+a3)
b4 = ey - b0 - (b1+b2+b3)
test_coefs1 = (a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)

plt.savefig('calc_multi_40_elev_01.png')
</code></pre>

<p><img alt="" src="calc_multi_40_elev_01.png" /></p>
<p>Eğer üstteki gidiş yoluna kuşbakışı, iki boyutlu ortamda bakmak istersek,</p>
<pre><code class="python">t = np.linspace(0,1.0,100)
x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4
plt.xlim(0,5.0)
plt.ylim(0,5.0)
plt.plot(x,y)
plt.savefig('calc_multi_40_elev_02.png')
</code></pre>

<p><img alt="" src="calc_multi_40_elev_02.png" /></p>
<p>Şimdi ikinci bir gidiş yoluna bakalım, başlangıç noktası aynı ama bitiş farklı,</p>
<pre><code class="python"># 2. gidis yolunun tanimi, dik cikip iniyor
a1,a2,a3 = 1.5, 3.0, 1.0
b1,b2,b3 = 0.0, 1.0, 1.0
a0,b0=(1.0,1.0)
ex,ey=(0.3,4.0)
a4 = ex - a0 - (a1+a2+a3)
b4 = ey - b0 - (b1+b2+b3)
test_coefs2 = (a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plt.savefig('calc_multi_40_elev_03.png')
</code></pre>

<p><img alt="" src="calc_multi_40_elev_03.png" /></p>
<p>Bu yolları tabii ki rasgele parametreler üzerinden yarattık, bunlar optimal
yollar değiller.</p>
<p>Optimallik için gereken çizgi entegralinin hesabına gelelim. Bu hesap için
gereken formül,</p>
<p>$$
\int_{t=0}^{t=1} f(x(t),y(t)) \sqrt{(\mathrm{d} x/\mathrm{d} t)^2 + (\mathrm{d} y/\mathrm{d} t)^2} \mathrm{d} t
$$</p>
<p>Formülde görülen $\mathrm{d} x/\mathrm{d} t$ ve $\mathrm{d} y/\mathrm{d} t$ ve bunların karesi,
toplamarın kareköku, vs. hesaplarını sembolik olarak altta yapalım,</p>
<pre><code class="python">import sympy

vars = 't a0 a1 a2 a3 b0 b1 b2 b3 gamma x y'
t, a0, a1, a2, a3, b0, b1, b2, b3, gamma, x, y = sympy.symbols(vars)

xdef = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4
ydef = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4

dxdt = sympy.diff(xdef,t)
print (dxdt)
dydt = sympy.diff(ydef,t)
print (dydt)
sqrtdef = sympy.sqrt(sympy.diff(xdef,t)**2 + sympy.diff(ydef,t))
print (sqrtdef)
</code></pre>

<pre><code>a1 + 2*a2*t + 3*a3*t**2 - 57.2*t**3
b1 + 2*b2*t + 3*b3*t**2 - 84.0*t**3
sqrt(b1 + 2*b2*t + 3*b3*t**2 - 84.0*t**3 + (a1 + 2*a2*t + 3*a3*t**2 - 57.2*t**3)**2)
</code></pre>

<p>Şimdi entegralin kendisine gelelim. Bu noktada üstteki sembolik programı
daha da ilerletip sembolik entegrali almayı deneyebilirdik. Fakat bu işlem
oldukca uzun zaman alıyor. Zaten daha ileride daha çetrefil yükseklik
fonksiyonları ile çalışmak istersek, o durumda da kullanabilecek bir metota
ihtiyacımız var. Burada sayısal entegral almak [1] bir seçenektir. Ama o
zaman optimizasyon için gereken gradyan hesabı nasıl olacak diye merak
edenler olabilir.. Cevap basit. Otomatik türev yöntemi ile! </p>
<p>Otomatik türev ile herhangi bir fonksiyonun türevini alabileceğimizi
biliyoruz, eh sayısal entegrasyon da herhangi bir metot olduğuna göre onun
türevini alabiliriz. Altta bu hesabı üstteki örnek yollar için görelim,</p>
<pre><code class="python">def trapz(y, dx):
    vals = np.nan_to_num(y[1:-1],0)
    tmp = np.sum(vals*2.0)    
    return (y[0]+tmp+y[-1])*(dx/2.0)

def intval(t,a0,a1,a2,a3,a4,b0,b1,b2,b3,b4):
   sq = np.sqrt(b1 + 2*b2*t + 3*b3*t**2 - 112.0*t**3 + (a1 + 2*a2*t + 3*a3*t**2 - 65.2*t**3)**2)
   x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
   y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4
   x = np.array(x)
   y = np.array(y)   
   z = gfunc(x,y)   
   res = z * sq
   T = trapz(res, 1.0/len(t))
   return T

t = np.linspace(0,1,100)

a0,a1,a2,a3,a4,b0,b1,b2,b3,b4 = test_coefs1
T = intval(t,a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
print (T)
a0,a1,a2,a3,a4,b0,b1,b2,b3,b4 = test_coefs2
T = intval(t,a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
print (T)
</code></pre>

<pre><code>1.624956808796678
5.534245013919315
</code></pre>

<p>Daha dik yolun entegrali daha yüksek çıktı, bu normal.</p>
<p>Şimdi optimal yolu bulalım,</p>
<pre><code class="python">from autograd.numpy import sqrt, exp, nan, e, log, power, sum
from autograd import numpy as np
from scipy import optimize
import autograd

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from scipy.spatial.distance import cdist
from matplotlib import cm


def trapz(y, dx):
    vals = y[1:-1]
    vals = vals[vals&gt;0.0]
    return (y[0]+sum(vals*2.0)+y[-1])*(dx/2.0)

def gfunc(x, y, offset=0.0):
    s1 = 2.2; x1 = 2.0; y1 = 2.0
    tmp = -4.0 *log(2.0) * ((x-x1)**2.0+(y-y1)**2.0) / s1**2.0
    g1 = np.array([power(e,_) if _ != nan else 0.0 for _ in tmp])
    return g1+offset

def pfunc(x, y):
    s1 = 2.2; x1 = 2.0; y1 = 2.0
    g1 = np.exp( -4 *np.log(2) * ((x-x1)**2+(y-y1)**2) / s1**2)
    return g1 

def plot_surf_path(azim,elev,a0,a1,a2,a3,a4,b0,b1,b2,b3,b4):

    D = 50
    x = np.linspace(0,5,D)
    y = np.linspace(0,5,D)
    xx,yy = np.meshgrid(x,y)
    zz = pfunc(xx,yy)

    fig = plt.figure()
    ax = fig.gca(projection='3d')
    ax.set_xlim(0,5)
    ax.set_ylim(0,5)
    ax.view_init(elev=elev, azim=azim)
    surf = ax.plot_wireframe(xx, yy, zz,rstride=10, cstride=10)

    t = np.linspace(0,1.0,100)

    x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
    y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4

    ax.plot3D(x, y, gfunc(x,y),'r.')

def find_path(ex,ey,a0,b0,offset):

    cons=({'type': 'ineq','fun': lambda x: 30.0-x[0]},
          {'type': 'ineq','fun': lambda x: 30.0-x[1]},
          {'type': 'ineq','fun': lambda x: 30.0-x[2]},
          {'type': 'ineq','fun': lambda x: 30.0-x[3]},
          {'type': 'ineq','fun': lambda x: 30.0-x[4]},
          {'type': 'ineq','fun': lambda x: 30.0-x[5]},
          {'type': 'ineq','fun': lambda x: x[0]},
          {'type': 'ineq','fun': lambda x: x[1]},
          {'type': 'ineq','fun': lambda x: x[2]},
          {'type': 'ineq','fun': lambda x: x[3]},
          {'type': 'ineq','fun': lambda x: x[4]},
          {'type': 'ineq','fun': lambda x: x[5]},
    )


    # rasgele secilmis baslangic degerleri
    a1,a2,a3 = 0.1,0.2,0.4
    b1,b2,b3 = 0.2,0.4,0.6
    x0 = a1,a2,a3,b1,b2,b3

    def pintval(p):
        a1,a2,a3,b1,b2,b3 = p
        a4 = ex - a0 - (a1+a2+a3)
        b4 = ey - b0 - (b1+b2+b3)   
        t = np.linspace(0,1,100)
        tmp = b1 + 2.0*b2*t + 3.0*b3*t**2.0 - 112.0*t**3.0 + (a1 + 2.0*a2*t + 3.0*a3*t**2.0 - 65.2*t**3.0)**2.0
        sq = [sqrt(_) if _ != nan else 0.0 for _ in tmp]
        x = a0 + a1*t + a2*t**2.0 + a3*t**3.0 + a4*t**4.0
        y = b0 + b1*t + b2*t**2.0 + b3*t**3.0 + b4*t**4.0
        x = np.array(x)
        y = np.array(y)   
        z = gfunc(x,y,offset)
        res = z * sq
        T = trapz(res, 1.0/len(t))
        print ('T',T)
        return T

    pintval_grad = autograd.grad(pintval)

    sol = optimize.minimize(pintval,
                            x0,
                            jac = pintval_grad,
                            method = 'COBYLA',
                            callback=print,
                            tol=0.05,
                            constraints=cons)

    print (sol.x)
    return sol.x

a0,b0=1.0,1.0
OFFSET = 1.0

ex,ey=0.3,4.0
res = find_path(ex,ey,a0,b0,OFFSET)
a1,a2,a3,b1,b2,b3 = res
a4 = ex - a0 - (a1+a2+a3)
b4 = ey - b0 - (b1+b2+b3)
print (a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plot_surf_path(-130,23,a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plt.savefig('calc_multi_40_elev_04.png')
#plt.show()

ex,ey=4.0,4.0
res = find_path(ex,ey,a0,b0,OFFSET)
a1,a2,a3,b1,b2,b3 = res
a4 = ex - a0 - (a1+a2+a3)
b4 = ey - b0 - (b1+b2+b3)
print (a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plot_surf_path(-90,36,a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plt.savefig('calc_multi_40_elev_05.png')
#plt.show()


</code></pre>

<p><img alt="" src="calc_multi_40_elev_04.png" /></p>
<p><img alt="" src="calc_multi_40_elev_05.png" /></p>
<p>[devam edecek]</p>
<p>Kaynaklar </p>
<p>[1] Bayramlı, Sayısal Bilim, <em>Sayısal Entegrasyon (Numerical Integration)</em></p>
<p>[2] Bayramlı, Cok Boyutlu Calculus, <em>Ders 19, Skalar Alanlar Uzerinden Cizgi Entegral</em></p>
<p>[3] Bayramlı, Cok Boyutlu Calculus, <em>Ders 5, İki Nokta Arasında Parametrize Edilmiş Eğri</em></p>