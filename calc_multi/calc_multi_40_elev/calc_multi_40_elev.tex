\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Yükseklik Fonksiyonu (Tepeler) Arasýndan En Düz, Optimal Yürüyüþ Yolunu Bulmak

Elimizde bir alan içindeki yükseklikleri veren bir fonksiyon $f(x,y)$
olduðunu düþünelim. Acaba verili bir baþlangýç ve bitiþ noktasý arasýndaki
en ``rahat'' gidiþ yolunu nasýl buluruz? 

Bu problem bir çizgi entegral hesabýna çevirilebilir. Bir skalar alan
üzerinden giden herhangi bir parametrize eðrinin altýndaki alaný
hesaplamayý biliyoruz [2]. Ayrýca istediðimiz derecede polinom parametrize
eðrileri nasýl yaratacaðýmýzý biliyoruz [3]. Bu fikirleri bir araya koyarsak,
geriye kalan bir optimizasyon problemidir. Çünkü en rahat yol, ``toplam
yüksekliði en az olan yol'' olarak görülebilir, ve burada çizgi entegrali
faydalý olur.

Önce yükseklikleri ve eðrileri iki örnek üzerinde görelim. Bir rasgele
tepe, ve bir rasgele yol çiziyoruz,

\begin{minted}[fontsize=\footnotesize]{python}
from mpl_toolkits.mplot3d import Axes3D
from scipy.spatial.distance import cdist
from matplotlib import cm

def gfunc(x, y):
    s1 = 2.2; x1 = 2.0; y1 = 2.0
    g1 = np.exp( -4 *np.log(2) * ((x-x1)**2+(y-y1)**2) / s1**2)
    return g1 

def plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4):

    D = 50
    x = np.linspace(0,5,D)
    y = np.linspace(0,5,D)
    xx,yy = np.meshgrid(x,y)
    zz = gfunc(xx,yy)

    fig = plt.figure()
    ax = fig.gca(projection='3d')
    ax.set_xlim(0,5)
    ax.set_ylim(0,5)
    surf = ax.plot_wireframe(xx, yy, zz,rstride=10, cstride=10)

    t = np.linspace(0,1.0,100)

    x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
    y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4

    ax.plot3D(x, y, gfunc(x,y),'r.')

# 1. gidis yolunun tanimi, uzun yoldan dolanarak gidiyor
a1,a2,a3 = 1.5, 8.1, 4.0
b1,b2,b3 = 0.3, 0.4, 23.3
a0,b0=(1.0,1.0)
ex,ey=(0.3,4.0)
a4 = ex - a0 - (a1+a2+a3)
b4 = ey - b0 - (b1+b2+b3)
test_coefs1 = (a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)

plt.savefig('calc_multi_40_elev_01.png')
\end{minted}

\includegraphics[width=20em]{calc_multi_40_elev_01.png}

Eðer üstteki gidiþ yoluna kuþbakýþý, iki boyutlu ortamda bakmak istersek,

\begin{minted}[fontsize=\footnotesize]{python}
t = np.linspace(0,1.0,100)
x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4
plt.xlim(0,5.0)
plt.ylim(0,5.0)
plt.plot(x,y)
plt.savefig('calc_multi_40_elev_02.png')
\end{minted}

\includegraphics[width=20em]{calc_multi_40_elev_02.png}

Þimdi ikinci bir gidiþ yoluna bakalým, baþlangýç noktasý ayný ama bitiþ farklý,

\begin{minted}[fontsize=\footnotesize]{python}
# 2. gidis yolunun tanimi, dik cikip iniyor
a1,a2,a3 = 1.5, 3.0, 1.0
b1,b2,b3 = 0.0, 1.0, 1.0
a0,b0=(1.0,1.0)
ex,ey=(0.3,4.0)
a4 = ex - a0 - (a1+a2+a3)
b4 = ey - b0 - (b1+b2+b3)
test_coefs2 = (a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plt.savefig('calc_multi_40_elev_03.png')
\end{minted}

\includegraphics[width=20em]{calc_multi_40_elev_03.png}

Bu yollarý tabii ki rasgele parametreler üzerinden yarattýk, bunlar optimal
yollar deðiller.

Optimallik için gereken çizgi entegralinin hesabýna gelelim. Bu hesap için
gereken formül,

$$
\int_{t=0}^{t=1} f(x(t),y(t)) \sqrt{(\ud x/\ud t)^2 + (\ud y/\ud t)^2} \ud t
$$

Formülde görülen $\ud x/\ud t$ ve $\ud y/\ud t$ ve bunlarýn karesi,
toplamarýn kareköku, vs. hesaplarýný sembolik olarak altta yapalým,

\begin{minted}[fontsize=\footnotesize]{python}
import sympy

vars = 't a0 a1 a2 a3 b0 b1 b2 b3 gamma x y'
t, a0, a1, a2, a3, b0, b1, b2, b3, gamma, x, y = sympy.symbols(vars)

xdef = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4
ydef = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4

dxdt = sympy.diff(xdef,t)
print (dxdt)
dydt = sympy.diff(ydef,t)
print (dydt)
sqrtdef = sympy.sqrt(sympy.diff(xdef,t)**2 + sympy.diff(ydef,t))
print (sqrtdef)
\end{minted}

\begin{verbatim}
a1 + 2*a2*t + 3*a3*t**2 - 57.2*t**3
b1 + 2*b2*t + 3*b3*t**2 - 84.0*t**3
sqrt(b1 + 2*b2*t + 3*b3*t**2 - 84.0*t**3 + (a1 + 2*a2*t + 3*a3*t**2 - 57.2*t**3)**2)
\end{verbatim}


Þimdi entegralin kendisine gelelim. Bu noktada üstteki sembolik programý
daha da ilerletip sembolik entegrali almayý deneyebilirdik. Fakat bu iþlem
oldukca uzun zaman alýyor. Zaten daha ileride daha çetrefil yükseklik
fonksiyonlarý ile çalýþmak istersek, o durumda da kullanabilecek bir metota
ihtiyacýmýz var. Burada sayýsal entegral almak [1] bir seçenektir. Ama o
zaman optimizasyon için gereken gradyan hesabý nasýl olacak diye merak
edenler olabilir.. Cevap basit. Otomatik türev yöntemi ile! 

Otomatik türev ile herhangi bir fonksiyonun türevini alabileceðimizi
biliyoruz [4], eh sayýsal entegrasyon da herhangi bir metot olduðuna göre
onun türevini alabiliriz. Altta bu hesabý üstteki örnek yollar için
görelim,

\begin{minted}[fontsize=\footnotesize]{python}
def trapz(y, dx):
    vals = np.nan_to_num(y[1:-1],0)
    tmp = np.sum(vals*2.0)    
    return (y[0]+tmp+y[-1])*(dx/2.0)

def intval(t,a0,a1,a2,a3,a4,b0,b1,b2,b3,b4):
   sq = np.sqrt(b1 + 2*b2*t + 3*b3*t**2 - 112.0*t**3 + (a1 + 2*a2*t + 3*a3*t**2 - 65.2*t**3)**2)
   x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
   y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4
   x = np.array(x)
   y = np.array(y)   
   z = gfunc(x,y)   
   res = z * sq
   T = trapz(res, 1.0/len(t))
   return T

t = np.linspace(0,1,100)

a0,a1,a2,a3,a4,b0,b1,b2,b3,b4 = test_coefs1
T = intval(t,a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
print (T)
a0,a1,a2,a3,a4,b0,b1,b2,b3,b4 = test_coefs2
T = intval(t,a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
print (T)
\end{minted}

\begin{verbatim}
1.624956808796678
5.534245013919315
\end{verbatim}

Daha dik yolun entegrali daha yüksek çýktý, bu normal.

Þimdi optimal yolu bulalým,

\inputminted[fontsize=\footnotesize]{python}{paths.py}

\includegraphics[width=20em]{calc_multi_40_elev_04.png}

\includegraphics[width=20em]{calc_multi_40_elev_05.png}

Dikkat edersek son kod içinde bazý fonksiyonlarý tekrar yazmamýz
gerekti. Bunun sebebi otomatik türev kütüphanesi \verb!autograd!'ýn kendi
içinde olan \verb!numpy! kodlarýný kullanmamýz gerekmesi. Yani dýþarýdan
\verb!numpy! deðil \verb!autograd! içindeki \verb!numpy!'i kullanmak lazým;
sebep o \verb!numpy!'in ``türevi alýnabilir'' bir hale getirilmiþ
olmasý. OT bir sihirli deðnek deðil, pek çok iyi yapýyor, daha önceden
hazýrlanmýþ öðeleri kullanmak þartýyla. 

Ayrýca bir \verb!OFFSET! parametresiyle yükseklik fonksiyonunun döndürdüðü
her yükseklik hesabýna bir \verb!OFFSET! kadar yüksekliði suni olarak
eklediðimize dikkat. Bunun sebebi yer seviyesinin 0 yükseklikte olmasý
sebebiyle sürekli tercih edilebilmesi, yani upuzun bir yol yer seviyesinden
gidebilir, çünkü orada gitmenin hiçbir bedeli yoktur. Biz de her yüksekliði
suni bir yükseklik ekleyerek yerdeki çok uzun yollarýn tercih edilmemesini
saðladýk.

Kaynaklar 

[1] Bayramlý, Sayýsal Bilim, {\em Sayýsal Entegrasyon (Numerical Integration)}

[2] Bayramlý, Cok Boyutlu Calculus, {\em Ders 19, Skalar Alanlar Uzerinden Cizgi Entegral}

[3] Bayramlý, Cok Boyutlu Calculus, {\em Ders 5, Ýki Nokta Arasýnda Parametrize Edilmiþ Eðri}

[4] Bayramlý, Bilgisayar Bilim, Yapay Zeka, {\em Otomatik Türev Almak}

[5] Bayramlý, Fonksiyonel Analiz ve Optimizasyon, {\em Autograd ile Optimizasyon}

\end{document}
