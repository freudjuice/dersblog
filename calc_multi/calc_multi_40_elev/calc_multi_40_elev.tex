\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Yükseklik Fonksiyonu (Tepeler) Arasýndan En Düz, Optimal Yürüyüþ Yolunu Bulmak

[yapim asamasinda]

Elimizde bir alan içindeki yükseklikleri veren bir fonksiyon $f(x,y)$
olduðunu düþünelim. Acaba verili bir baþlangýç ve bitiþ noktasý arasýndaki
en ``rahat'' gidiþ yolunu nasýl buluruz? 

xxxxxxxxxxxxxxx

Önce yükseklikleri ve eðrileri iki örnek üzerinde görelim. Bir rasgele
tepe, ve bir rasgele yol çiziyoruz,

\begin{minted}[fontsize=\footnotesize]{python}
from mpl_toolkits.mplot3d import Axes3D
from scipy.spatial.distance import cdist
from matplotlib import cm

def gfunc(x, y):
    s1 = 2.2; x1 = 2.0; y1 = 2.0
    g1 = np.exp( -4 *np.log(2) * ((x-x1)**2+(y-y1)**2) / s1**2)
    return g1 

def plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4):

    D = 50
    x = np.linspace(0,5,D)
    y = np.linspace(0,5,D)
    xx,yy = np.meshgrid(x,y)
    zz = gfunc(xx,yy)

    fig = plt.figure()
    ax = fig.gca(projection='3d')
    ax.set_xlim(0,5)
    ax.set_ylim(0,5)
    surf = ax.plot_wireframe(xx, yy, zz,rstride=10, cstride=10)

    t = np.linspace(0,1.0,100)

    x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
    y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4

    ax.plot3D(x, y, gfunc(x,y),'r.')

# 1. gidis yolunun tanimi, uzun yoldan dolanarak gidiyor
a1,a2,a3 = 1.5, 8.1, 4.0
b1,b2,b3 = 0.3, 0.4, 23.3
a0,b0=(1.0,1.0)
ex,ey=(0.3,4.0)
a4 = ex - a0 - (a1+a2+a3)
b4 = ey - b0 - (b1+b2+b3)
test_coefs1 = (a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)

plt.savefig('calc_multi_40_elev_01.png')
\end{minted}

\includegraphics[width=20em]{calc_multi_40_elev_01.png}

Eðer üstteki gidiþ yoluna kuþbakýþý, iki boyutlu ortamda bakmak istersek,

\begin{minted}[fontsize=\footnotesize]{python}
t = np.linspace(0,1.0,100)
x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4
plt.xlim(0,5.0)
plt.ylim(0,5.0)
plt.plot(x,y)
plt.savefig('calc_multi_40_elev_02.png')
\end{minted}

\includegraphics[width=20em]{calc_multi_40_elev_02.png}

Þimdi ikinci bir gidiþ yoluna bakalým, baþlangýç noktasý ayný ama bitiþ farklý,

\begin{minted}[fontsize=\footnotesize]{python}
# 2. gidis yolunun tanimi, dik cikip iniyor
a1,a2,a3 = 1.5, 3.0, 1.0
b1,b2,b3 = 0.0, 1.0, 1.0
a0,b0=(1.0,1.0)
ex,ey=(0.3,4.0)
a4 = ex - a0 - (a1+a2+a3)
b4 = ey - b0 - (b1+b2+b3)
test_coefs2 = (a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plt.savefig('calc_multi_40_elev_03.png')
\end{minted}

\includegraphics[width=20em]{calc_multi_40_elev_03.png}

Bu yollarý tabii ki rasgele parametreler üzerinden yarattýk, bunlar optimal
yollar deðiller.

Optimallik için gereken uzunluk hesabýna gelelim. Bu hesap için
formül,

xxxxxxxxxxxxxx

Formülde görülen $\ud x/\ud t$ ve $\ud y/\ud t$, parametrik eðri formülünü
tekrar yazalým, 

$$
x(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3
$$

$$
y(t) = b_0 + b_1 t + b_2 t^2 + b_3 t^3
$$

ve türev, bunlarýn karesi hesaplarýný sembolik olarak altta yapalým,

\begin{minted}[fontsize=\footnotesize]{python}
import sympy

vars = 't a0 a1 a2 a3 b0 b1 b2 b3 gamma x y'
t, a0, a1, a2, a3, b0, b1, b2, b3, gamma, x, y = sympy.symbols(vars)

xdef = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4
ydef = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4

dxdt = sympy.diff(xdef,t)
print (dxdt)
dydt = sympy.diff(ydef,t)
print (dydt)
sqrtdef = sympy.sqrt(sympy.diff(xdef,t)**2 + sympy.diff(ydef,t))
print (sqrtdef)
\end{minted}

\begin{verbatim}
a1 + 2*a2*t + 3*a3*t**2 - 57.2*t**3
b1 + 2*b2*t + 3*b3*t**2 - 84.0*t**3
sqrt(b1 + 2*b2*t + 3*b3*t**2 - 84.0*t**3 + (a1 + 2*a2*t + 3*a3*t**2 - 57.2*t**3)**2)
\end{verbatim}


Þimdi entegralin kendisine gelelim. Bu noktada üstteki sembolik programý
daha da ilerletip sembolik entegrali almayý deneyebilirdik. Fakat bu iþlem
oldukca uzun zaman alýyor. Zaten daha ileride daha çetrefil yükseklik
fonksiyonlarý ile çalýþmak istersek, o durumda da kullanabilecek bir metota
ihtiyacýmýz var. Burada sayýsal entegral almak [1] bir seçenektir. Ama o
zaman optimizasyon için gereken gradyan hesabý nasýl olacak diye merak
edenler olabilir.. Bazi optimizasyon rutinleri gradyan olmadan da
isleyebiliyor. 

Altta entegral hesabýný üstteki örnek yollar için görelim,

Daha dik yolun entegrali daha yüksek çýktý, bu normal.

Þimdi optimal yolu bulalým,


Iki Tepe, RBF

Ýþleri biraz daha zorlaþtýralým. Gerçek dünya þartlarýnda bir bölgenin
yükseklik verisinden örneklem toplayýp, bu verileri RBF ile modelleyip [4],
o modeli yükseklik için kullanmak isteyebiliriz. Eðer herhangi bir $x,y$
noktasýnýn yüksekliðinin verecek RBF toplam fonksiyonunu temiz bir þekilde
iþletmenin yolunu bulabilirsek, bunun üzerinden çizgi entegrali, ve bu
entegral fonksiyonun \verb!autograd! türevi üzerinden minimizasyonunu
yapabiliriz.

Hatta daha da zorlaþtýralým, gerçek dünya þartlarýnda coðrafik kordinatlarý
da parçalara bölüp her parça üzerinde RBF modellemesi yapmak
gerekebilir. Diyelim ki kordinatlarý tam sayý bazýnda bölüyoruz, mesela tüm
enlem/boylam (36,32) kordinatlarý bir blok (Alanya çevresi), (36,33) bir
baþka blok. Her tam sayýlý alan yaklaþýk 9,300 $km^2$'ye tekabül eder. Bu
yeterince büyük bir alan, oradaki tepeleri modellemek ise yarar. Her neyse,
diyelim ki bir hesap için (36,32), ve (36,33) RBF'lerini bir sözlük içine
alýyoruz, ve bu iki RBF bloðu üzerinden optimizasyonun olmasýný
saðlayalým. 

Test amaçlý bir blok içinde iki tepe yaratalým, sonra ayný tepeleri bir
baþka blok içinde yaratacaðýz, ve ikisini yanyana koyacaðýz. 

xxxxxxxxxxxxxxxxx


Þimdi çizgi entegrali hesabý ve optimizasyon için gerekli rutinleri
yazalým, ve bir baþlangýç noktasý \verb!(36.0,32.0)!'dan
\verb!(36.4,34.0)!'a giden optimal yolu bulmaya çalýþalým.  Kodlamadaki
deðiþimi açýk olsun, \verb!import numpy as anp!  ile dahil edilen
\verb!numpy! versiyonunu farklý isimlendirdik.



Kaynaklar 

[1] Bayramlý, Sayýsal Bilim, {\em Sayýsal Entegrasyon (Numerical Integration)}

[2] Bayramlý, Cok Boyutlu Calculus, {\em Ders 19, Skalar Alanlar Uzerinden Cizgi Entegral}

[3] Bayramlý, Cok Boyutlu Calculus, {\em Ders 5, Ýki Nokta Arasýnda Parametrize Edilmiþ Eðri}

[4] Bayramlý, Ýstatistik ve Veri Analizi, {\em Dairesel Baz Fonksiyonlarý (Radial Basis Functions -RBF-)}

[5] Bayramlý, Fonksiyonel Analiz ve Optimizasyon, {\em Autograd ile Optimizasyon}

\end{document}

