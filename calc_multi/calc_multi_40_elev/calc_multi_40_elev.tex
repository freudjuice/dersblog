\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Yükseklik Fonksiyonu (Tepeler) Arasýndan En Düz, Optimal Yürüyüþ Yolunu Bulmak

Elimizde bir alan içindeki yükseklikleri veren bir fonksiyon $f(x,y)$
olduðunu düþünelim. Acaba verili bir baþlangýç ve bitiþ noktasý arasýndaki
en ``rahat'' gidiþ yolunu nasýl buluruz? 

Bu problem bir çizgi entegral hesabýna çevirilebilir. Bir skalar alan
üzerinden giden herhangi bir parametrize eðrinin altýndaki alaný
hesaplamayý biliyoruz [2]. Ayrýca istediðimiz derecede polinom parametrize
eðrileri nasýl yaratacaðýmýzý biliyoruz [3]. Bu fikirleri bir araya koyarsak,
geriye kalan bir optimizasyon problemidir. Çünkü en rahat yol, ``toplam
yüksekliði en az olan yol'' olarak görülebilir, ve burada çizgi entegrali
faydalý olur.

Önce yükseklikleri ve eðrileri iki örnek üzerinde görelim. Bir rasgele
tepe, ve bir rasgele yol çiziyoruz,

\begin{minted}[fontsize=\footnotesize]{python}
from mpl_toolkits.mplot3d import Axes3D
from scipy.spatial.distance import cdist
from matplotlib import cm

def gfunc(x, y):
    s1 = 2.2; x1 = 2.0; y1 = 2.0
    g1 = np.exp( -4 *np.log(2) * ((x-x1)**2+(y-y1)**2) / s1**2)
    return g1 

def plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4):

    D = 50
    x = np.linspace(0,5,D)
    y = np.linspace(0,5,D)
    xx,yy = np.meshgrid(x,y)
    zz = gfunc(xx,yy)

    fig = plt.figure()
    ax = fig.gca(projection='3d')
    ax.set_xlim(0,5)
    ax.set_ylim(0,5)
    surf = ax.plot_wireframe(xx, yy, zz,rstride=10, cstride=10)

    t = np.linspace(0,1.0,100)

    x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
    y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4

    ax.plot3D(x, y, gfunc(x,y),'r.')

# 1. gidis yolunun tanimi, uzun yoldan dolanarak gidiyor
a1,a2,a3 = 1.5, 8.1, 4.0
b1,b2,b3 = 0.3, 0.4, 23.3
a0,b0=(1.0,1.0)
ex,ey=(0.3,4.0)
a4 = ex - a0 - (a1+a2+a3)
b4 = ey - b0 - (b1+b2+b3)
test_coefs1 = (a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)

plt.savefig('calc_multi_40_elev_01.png')
\end{minted}

\includegraphics[width=20em]{calc_multi_40_elev_01.png}

Eðer üstteki gidiþ yoluna kuþbakýþý, iki boyutlu ortamda bakmak istersek,

\begin{minted}[fontsize=\footnotesize]{python}
t = np.linspace(0,1.0,100)
x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4
plt.xlim(0,5.0)
plt.ylim(0,5.0)
plt.plot(x,y)
plt.savefig('calc_multi_40_elev_02.png')
\end{minted}

\includegraphics[width=20em]{calc_multi_40_elev_02.png}

Þimdi ikinci bir gidiþ yoluna bakalým, baþlangýç noktasý ayný ama bitiþ farklý,

\begin{minted}[fontsize=\footnotesize]{python}
# 2. gidis yolunun tanimi, dik cikip iniyor
a1,a2,a3 = 1.5, 3.0, 1.0
b1,b2,b3 = 0.0, 1.0, 1.0
a0,b0=(1.0,1.0)
ex,ey=(0.3,4.0)
a4 = ex - a0 - (a1+a2+a3)
b4 = ey - b0 - (b1+b2+b3)
test_coefs2 = (a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plt.savefig('calc_multi_40_elev_03.png')
\end{minted}

\includegraphics[width=20em]{calc_multi_40_elev_03.png}

Bu yollarý tabii ki rasgele parametreler üzerinden yarattýk, bunlar optimal
yollar deðiller.

Optimallik için gereken çizgi entegralinin hesabýna gelelim. Bu hesap için
formül,

$$
\int_{t=0}^{t=1} f(x(t),y(t)) \sqrt{(\ud x/\ud t)^2 + (\ud y/\ud t)^2} \ud t
$$

Formülde görülen $\ud x/\ud t$ ve $\ud y/\ud t$, parametrik eðri formülünü
tekrar yazalým, 

$$
x(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3
$$

$$
y(t) = b_0 + b_1 t + b_2 t^2 + b_3 t^3
$$

ve türev, bunlarýn karesi, toplamlarýn karekoku, vs. hesaplarýný sembolik
olarak altta yapalým,

\begin{minted}[fontsize=\footnotesize]{python}
import sympy

vars = 't a0 a1 a2 a3 b0 b1 b2 b3 gamma x y'
t, a0, a1, a2, a3, b0, b1, b2, b3, gamma, x, y = sympy.symbols(vars)

xdef = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4
ydef = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4

dxdt = sympy.diff(xdef,t)
print (dxdt)
dydt = sympy.diff(ydef,t)
print (dydt)
sqrtdef = sympy.sqrt(sympy.diff(xdef,t)**2 + sympy.diff(ydef,t))
print (sqrtdef)
\end{minted}

\begin{verbatim}
a1 + 2*a2*t + 3*a3*t**2 - 57.2*t**3
b1 + 2*b2*t + 3*b3*t**2 - 84.0*t**3
sqrt(b1 + 2*b2*t + 3*b3*t**2 - 84.0*t**3 + (a1 + 2*a2*t + 3*a3*t**2 - 57.2*t**3)**2)
\end{verbatim}


Þimdi entegralin kendisine gelelim. Bu noktada üstteki sembolik programý
daha da ilerletip sembolik entegrali almayý deneyebilirdik. Fakat bu iþlem
oldukca uzun zaman alýyor. Zaten daha ileride daha çetrefil yükseklik
fonksiyonlarý ile çalýþmak istersek, o durumda da kullanabilecek bir metota
ihtiyacýmýz var. Burada sayýsal entegral almak [1] bir seçenektir. Ama o
zaman optimizasyon için gereken gradyan hesabý nasýl olacak diye merak
edenler olabilir.. Bazi optimizasyon rutinleri gradyan olmadan da
isleyebiliyor. 

Altta entegral hesabýný üstteki örnek yollar için görelim,

\begin{minted}[fontsize=\footnotesize]{python}
def trapz(y, dx):
    vals = np.nan_to_num(y[1:-1],0)
    tmp = np.sum(vals*2.0)    
    return (y[0]+tmp+y[-1])*(dx/2.0)

def intval(t,a0,a1,a2,a3,a4,b0,b1,b2,b3,b4):
   sq = np.sqrt(b1 + 2*b2*t + 3*b3*t**2 - 112.0*t**3 + (a1 + 2*a2*t + 3*a3*t**2 - 65.2*t**3)**2)
   x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
   y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4
   x = np.array(x)
   y = np.array(y)   
   z = gfunc(x,y)   
   res = z * sq
   T = trapz(res, 1.0/len(t))
   return T

t = np.linspace(0,1,100)

a0,a1,a2,a3,a4,b0,b1,b2,b3,b4 = test_coefs1
T = intval(t,a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
print (T)
a0,a1,a2,a3,a4,b0,b1,b2,b3,b4 = test_coefs2
T = intval(t,a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
print (T)
\end{minted}

\begin{verbatim}
1.624956808796678
5.534245013919315
\end{verbatim}

Daha dik yolun entegrali daha yüksek çýktý, bu normal.

Þimdi optimal yolu bulalým,

\inputminted[fontsize=\footnotesize]{python}{paths.py}

\includegraphics[width=20em]{calc_multi_40_elev_04.png}

\includegraphics[width=20em]{calc_multi_40_elev_05.png}

Ayrýca bir \verb!offset! parametresiyle yükseklik fonksiyonunun döndürdüðü
her yükseklik hesabýna bir \verb!offset! kadar yüksekliði suni olarak
eklediðimize dikkat. Bunun sebebi yer seviyesinin 0 yükseklikte olmasý
sebebiyle sürekli tercih edilebilmesi, yani upuzun bir yol yer seviyesinden
gidebilir, çünkü orada gitmenin hiçbir bedeli yoktur. Biz de her yüksekliði
suni bir yükseklik ekleyerek yerdeki çok uzun yollarýn tercih edilmemesini
saðladýk.

Iki Tepe, RBF

Ýþleri biraz daha zorlaþtýralým. Gerçek dünya þartlarýnda bir bölgenin
yükseklik verisinden örneklem toplayýp, bu verileri RBF ile modelleyip [4],
o modeli yükseklik için kullanmak isteyebiliriz. Eðer herhangi bir $x,y$
noktasýnýn yüksekliðinin verecek RBF toplam fonksiyonunu temiz bir þekilde
iþletmenin yolunu bulabilirsek, bunun üzerinden çizgi entegrali, ve bu
entegral fonksiyonun `autoðgrad` türevi üzerinden minimizasyonunu
yapabiliriz. 

Hatta daha da zorlaþtýralým, gerçek dünya þartlarýnda coðrafik kordinatlarý
da parçalara bölüp her parça üzerinde RBF modellemesi yapmak
gerekebilir. Diyelim ki kordinatlarý tam sayý bazýnda bölüyoruz, mesela tüm
enlem/boylam (36,32) kordinatlarý bir blok (Alanya çevresi), (36,33) bir
baþka blok. Her tam sayýlý alan yaklaþýk 9,300 $km^2$'ye tekabül eder. Bu
yeterince büyük bir alan, oradaki tepeleri modellemek ise yarar. Her neyse,
diyelim ki bir hesap için (36,32), ve (36,33) RBF'lerini bir sözlük içine
alýyoruz, ve bu iki RBF bloðu üzerinden optimizasyonun olmasýný
saðlayalým. 

Test amaçlý bir blok içinde iki tepe yaratalým, sonra ayný tepeleri bir
baþka blok içinde yaratacaðýz, ve ikisini yanyana koyacaðýz. 

Þimdi çizgi entegrali hesabý ve optimizasyon için gerekli rutinleri
yazalým, ve bir baþlangýç noktasý \verb!(36.0,32.0)!'dan
\verb!(36.4,34.0)!'a giden optimal yolu bulmaya çalýþalým.

Autograd, Otomatik Türev

Þimdiye kadar gördüðümüz yöntem gradyan /türev bilgisinin sayýsal olarak
hesaplayan bir yöntem kullandý, ÇOBYLA. Fakat gradyan bilgisini otomatik
türev olarak aldýrýp (sembolik türev ile ayný kuvvette), minimizasyon
adýmýný kendimiz de atabilirdik. Ayrýca sýnýr þartlarýný [5]'te gördüðümüz
gibi log-bariyer yöntemi ile kendimiz sisteme dahil edebilirdik.

Ýki tepeli örnek üzerinde görelim. Tepeleri yaratýp, örneklem alýp, RBF
modelleme yapýyoruz, o modelle çizgi entegrali hesaplýyoruz, ve belli
baþlangýç bitiþ noktalarýna tekabül eden katsayýlar üzerinden bu entegrali
minimize etmek istiyoruz. 

Fakat bir fark var, RBF ile yükseklik hesaplayan metotun türevini otomatik
olarak alacaðýz. Bu sebeple entegral, ve onun içinde çaðýrdýðý tüm metotlar
``autograd-perver'' olmalý.  Ayrýca Autograd, perde arkasýnda Python kodu
üzerinde bazý temelden deðiþimler yapar, ve bu sebeple metotlarýn autograd
üzerinden, ve autograd dýþýndan çaðrýlmalarýnda farklýlýklar olabiliyor,
ayrýca her türlü Python çaðrýsýný autograd-perver kodlar içinden
yapamayabiliriz. 

Neyse, kodlamayý yapalým. Kodlamadaki deðiþimi açýk olsun,
\verb!import numpy as anp!  ile dahil edilen \verb!numpy! versiyoununu
farklý isimlendirdik.

Gradyan iniþi için gereken gradyan her parametre için
\verb!autograd.grad(intval,...)! ile alýnýr [5], ve 0,1,2,.. diye giden
parametreler sýrasýyla egrinin katsayýlarý $a_1,a_2,..$'ye tekabül ediyor.

\inputminted[fontsize=\footnotesize]{python}{paths2.py}

\includegraphics[width=18em]{linear_app88rbf_08-0.png}
\includegraphics[width=18em]{linear_app88rbf_08-1.png}

\includegraphics[width=18em]{linear_app88rbf_08-2.png}
\includegraphics[width=18em]{linear_app88rbf_08-3.png}

\includegraphics[width=18em]{linear_app88rbf_08-4.png}
\includegraphics[width=18em]{linear_app88rbf_08-5.png}

Üstte her gradyan adýmý sonrasý hesaplanan yollarý görüyoruz. Rasgele
katsayýlarla baþladýk (ilk grafik), ve tek bir gradyan iniþi adýmý ile
optimal bir yola oldukca yaklaþtýk. Bir adým daha daha da iyi sonuç verdi.

Ýþte görüldüðü gibi son derece çetrefil bir fonksiyon olsa da türevi rahat
bir þekilde hesaplamýþ oluyoruz. 

Kaynaklar 

[1] Bayramlý, Sayýsal Bilim, {\em Sayýsal Entegrasyon (Numerical Integration)}

[2] Bayramlý, Cok Boyutlu Calculus, {\em Ders 19, Skalar Alanlar Uzerinden Cizgi Entegral}

[3] Bayramlý, Cok Boyutlu Calculus, {\em Ders 5, Ýki Nokta Arasýnda Parametrize Edilmiþ Eðri}

[4] Bayramlý, Ýstatistik ve Veri Analizi, {\em Dairesel Baz Fonksiyonlarý (Radial Basis Functions -RBF-)}

[5] Bayramlý, Fonksiyonel Analiz ve Optimizasyon, {\em Autograd ile Optimizasyon}


\end{document}



