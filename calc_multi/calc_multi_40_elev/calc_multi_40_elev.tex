\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Yükseklik Fonksiyonu (Tepeler) Arasýndan En Düz, Optimal Yürüyüþ Yolunu Bulmak

Elimizde bir alan içindeki yükseklikleri veren bir fonksiyon $f(x,y)$
olduðunu düþünelim. Acaba verili bir baþlangýç ve bitiþ noktasý arasýndaki
en ``rahat'' gidiþ yolunu nasýl buluruz? 

Yükseklikler bir $E(x,y)$ fonksiyonunda olsun. Yollarý nasýl temsil ederiz?
Bir parametrik eðri kullanabiliriz, mesela 

$$
x(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3
$$

$$
y(t) = b_0 + b_1 t + b_2 t^2 + b_3 t^3
$$

Ýstediðimiz derecede polinom parametrize eðrileri nasýl yaratacaðýmýzý
biliyoruz [3]. Böylece doðru, optimal bir yolu bulmak demek
$a_0,a_1,a_2,a_3,b_0,b_1,b_2,b_3$ katsayýlarýný doðru bulmak demek
olacaktýr. Bir optimizasyon problemi yani.

Peki o zaman optimize, minimize edilecek bedel fonksiyonu ne olmalý? Burada
farklý yaklaþýmlar olabilir. Kimisi eðri altýna düþen yüksekliklerin
toplamýný bir çizgi entegrali ile hesaplamak isteyebilir. Fakat bu yaklaþým
yüksekliklerden genel olarak uzak dursa da mesela çok iniþli çýkýþlý
yollarý hala tercih eder, ama bu tür yollarýn yürüyüþ olarak yorucu
olacaðýný biliyoruz. 1000 metrelik bir tepeye çýkýp onun üzerinde düz
yürümek habire 1000 metreyi inmek çýkmaktan çok daha rahat.

Þu þekilde bir bedel belki daha iyi; Bir eðriyi düþünelim, onun $z$
eksenindeki yansýmasý da bir eðridir, $x,y$ düzlemindeki yansýmasý bir
baþka eðri. Bu eðrilerin {\em uzunluðunu} hesaplarsak ve dikey yöndeki
uzunluðu yatay olan uzunluðu farklý aðýrlýklarla çarpýp toplarsak bu bir
bedeli temsil eder. Aðýrlýk dikey/yatay uzunluklar için 5/1 oranýnda
olabilir, o zaman yatay yöndeki bir uzunluk / katedilen yol dikeye göre 5
kat daha tercih edilir olur.

Önce yükseklikleri ve eðrileri iki örnek üzerinde görelim. Bir rasgele
tepe, ve bir rasgele yol çiziyoruz,

\begin{minted}[fontsize=\footnotesize]{python}
from mpl_toolkits.mplot3d import Axes3D
from scipy.spatial.distance import cdist
from matplotlib import cm

def gfunc(x, y):
    s1 = 2.2; x1 = 2.0; y1 = 2.0
    g1 = np.exp( -4 *np.log(2) * ((x-x1)**2+(y-y1)**2) / s1**2)
    return g1 * 10.0

def plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4):

    D = 50
    x = np.linspace(0,5,D)
    y = np.linspace(0,5,D)
    xx,yy = np.meshgrid(x,y)
    zz = gfunc(xx,yy)

    fig = plt.figure()
    ax = fig.gca(projection='3d')
    ax.set_xlim(0,5)
    ax.set_ylim(0,5)
    surf = ax.plot_wireframe(xx, yy, zz,rstride=10, cstride=10)

    t = np.linspace(0,1.0,100)

    x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
    y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4

    ax.plot3D(x, y, gfunc(x,y),'r.')

# 1. gidis yolunun tanimi, uzun yoldan dolanarak gidiyor
a1,a2,a3 = 1.5, 8.1, 4.0
b1,b2,b3 = 0.3, 0.4, 23.3
a0,b0=(1.0,1.0)
ex,ey=(0.3,4.0)
a4 = ex - a0 - (a1+a2+a3)
b4 = ey - b0 - (b1+b2+b3)
test_coefs1 = (a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)

plt.savefig('calc_multi_40_elev_01.png')
\end{minted}

\includegraphics[width=20em]{calc_multi_40_elev_01.png}

Eðer üstteki gidiþ yoluna kuþbakýþý, iki boyutlu ortamda bakmak istersek,

\begin{minted}[fontsize=\footnotesize]{python}
t = np.linspace(0,1.0,100)
x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4
plt.xlim(0,5.0)
plt.ylim(0,5.0)
plt.plot(x,y)
plt.savefig('calc_multi_40_elev_02.png')
\end{minted}

\includegraphics[width=20em]{calc_multi_40_elev_02.png}

Bu biraz önce bahsettiðimiz yatay düzlemdeki yansýma.

Þimdi ikinci bir gidiþ yoluna bakalým, baþlangýç noktasý ayný ama bitiþ farklý,

\begin{minted}[fontsize=\footnotesize]{python}
# 2. gidis yolunun tanimi, dik cikip iniyor
a1,a2,a3 = 1.5, 3.0, 1.0
b1,b2,b3 = 0.0, 1.0, 1.0
a0,b0=(1.0,1.0)
ex,ey=(0.3,4.0)
a4 = ex - a0 - (a1+a2+a3)
b4 = ey - b0 - (b1+b2+b3)
test_coefs2 = (a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plt.savefig('calc_multi_40_elev_03.png')
\end{minted}

\includegraphics[width=20em]{calc_multi_40_elev_03.png}

Bu yollarý tabii ki rasgele parametreler üzerinden yarattýk, bunlar optimal
yollar deðiller.

Optimallik için gereken uzunluk hesabýna gelelim. Bu hesap için
formül, dikey için $I_v$ yatay için $I_h$

$$
I_v = \int_{t=0}^{t=1} \sqrt{1 + \left(\frac{\ud z}{\ud t} \right)^2 } \ud t
$$

$$
I_h = \int_{t=0}^{t=1} \sqrt{
\left(\frac{\ud x}{\ud t} \right)^2 + 
\left(\frac{\ud y}{\ud t} \right)^2
} 
\ud t
$$


Formülde görülen $\ud z/\ud t$, $\ud x/\ud t$ ve $\ud y/\ud t$, parametrik
eðri üzerinden alýnacak tabii ki. Problem çözümü açýsýndan $\ud z/\ud t$
hesabý külfetli olabilir, çünkü $z = f(x,y)$ yükþelik
fonksiyonundur. Üstteki örnekteki yükseklik fonksiyonu basit, ama daha
çetrefil durumlarda da kullanabileceðimiz bir yaklaþým daha iyi olur. Bu
sebeple $\ud z/\ud t$ türevini hesapsal yapacaðýz.

Ama yatay türevler $\ud x/\ud t$ ve $\ud y/\ud t$ için, türevi almak, kare,
toplam, karekök hesaplarýný sembolik olarak yapabiliriz, çünkü bu formül
polinom, formu þimdiden belli.

\begin{minted}[fontsize=\footnotesize]{python}
import sympy

vars = 't a0 a1 a2 a3 b0 b1 b2 b3 gamma x y'
t, a0, a1, a2, a3, b0, b1, b2, b3, gamma, x, y = sympy.symbols(vars)

xdef = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4
ydef = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4

dxdt = sympy.diff(xdef,t)
print (dxdt)
dydt = sympy.diff(ydef,t)
print (dydt)
sqrtdef = sympy.sqrt(sympy.diff(xdef,t)**2 + sympy.diff(ydef,t))
print (sqrtdef)
\end{minted}

\begin{verbatim}
a1 + 2*a2*t + 3*a3*t**2 - 57.2*t**3
b1 + 2*b2*t + 3*b3*t**2 - 84.0*t**3
sqrt(b1 + 2*b2*t + 3*b3*t**2 - 84.0*t**3 + (a1 + 2*a2*t + 3*a3*t**2 - 57.2*t**3)**2)
\end{verbatim}

Entegraller $I_v,I_h$ hesaplarý da sayýsal yapýlacak.

Hepsini bir araya koyarsak, uzunluklar (entegraller) üzerinden bir bedel
elde ediyoruz, ve bu bedeli minimize edecek eðri parametrelerini bulmak
için ise optimizasyon iþletiyoruz. Optimizasyon kýsýtlamalar içerecek, eðri
parametrelerinin -5/+5 arasýnda olmasýný istiyoruz mesela.

\inputminted[fontsize=\footnotesize]{python}{paths2.py}

\begin{verbatim}
res  barrier_parameter: 6.400000000000003e-06
 barrier_tolerance: 6.400000000000003e-06
          cg_niter: 1604
      cg_stop_cond: 2
            constr: [array([-1.08548354, -0.36789632, -0.20897387,  0.2395503 ,  0.29868552,
        0.00380265])]
       constr_nfev: [0]
       constr_nhev: [0]
       constr_njev: [0]
    constr_penalty: 1.0
  constr_violation: 0.0
    execution_time: 50.29004144668579
               fun: 33.11613644482912
              grad: array([-1.38273935, -0.50301313,  0.79182863,  1.80994987,  2.2042923 ,
        2.09085321])
               jac: [<6x6 sparse matrix of type '<class 'numpy.float64'>'
	with 6 stored elements in Compressed Sparse Row format>]
   lagrangian_grad: array([-1.2659412 , -0.46518832,  0.73288924,  1.67502195,  2.03938462,
        1.93597495])
           message: 'The maximum number of function evaluations is exceeded.'
            method: 'tr_interior_point'
              nfev: 2723
              nhev: 0
               nit: 301
             niter: 301
              njev: 0
        optimality: 2.0393846199040575
            status: 0
           success: False
         tr_radius: 1.8588829764195948e-08
                 v: [array([ 0.11679815,  0.03782481, -0.05893939, -0.13492793, -0.16490768,
       -0.15487826])]
                 x: array([-1.08548354, -0.36789632, -0.20897387,  0.2395503 ,  0.29868552,
        0.00380265])
res [-1.08548354 -0.36789632 -0.20897387  0.2395503   0.29868552  0.00380265]
\end{verbatim}

Bir optimal sonuç bulundu. Grafikleyelim,

\begin{minted}[fontsize=\footnotesize]{python}
a1,a2,a3,b1,b2,b3 = -1.08548354, -0.36789632, -0.20897387,  0.2395503,   0.29868552,  0.00380265
a4 = ex - a0 - (a1+a2+a3)
b4 = ey - b0 - (b1+b2+b3)
plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plt.savefig('calc_multi_40_elev_04.png')
\end{minted}

\includegraphics[width=20em]{calc_multi_40_elev_04.png}

Yol oldukca optimal duruyor. Gereksiz iniþ çýkýþ yok, ve yatay mesafe de
minimize edilmiþ. 

Kaynaklar 

[1] Bayramlý, Sayýsal Bilim, {\em Sayýsal Entegrasyon (Numerical Integration)}

[2] Bayramlý, Cok Boyutlu Calculus, {\em Ders 19, Skalar Alanlar Uzerinden Cizgi Entegral}

[3] Bayramlý, Cok Boyutlu Calculus, {\em Ders 5, Ýki Nokta Arasýnda Parametrize Edilmiþ Eðri}

[4] Bayramlý, Ýstatistik ve Veri Analizi, {\em Dairesel Baz Fonksiyonlarý (Radial Basis Functions -RBF-)}

[5] Bayramlý, Fonksiyonel Analiz ve Optimizasyon, {\em Newton-umsu Metotlar, DFP, BFGS }





\end{document}

