<h1>Yükseklik Fonksiyonu (Tepeler) Arasından En Düz, Optimal Yürüyüş Yolunu Bulmak</h1>
<!DOCTYPE html>
<html>
  <head>
    <title>Yükseklik Fonksiyonu (Tepeler) Arasından En Düz, Optimal Yürüyüş Yolunu Bulmak
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [["$","$"]]}
      });
    MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
      MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
        cancel: ["Extension","cancel"],
        bcancel: ["Extension","cancel"],
        xcancel: ["Extension","cancel"],
        cancelto: ["Extension","cancel"]
      });
    });
    </script>
<script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full">
</script>
</head>

<p>[yapım aşamasında]</p>
<p>Elimizde bir alan içindeki yükseklikleri veren bir fonksiyon $f(x,y)$
olduğunu düşünelim. Acaba verili bir başlangıç ve bitiş noktası arasındaki
en "rahat" gidiş yolunu nasıl buluruz? </p>
<p>xxxxxxxxxxxxxxx</p>
<p>Önce yükseklikleri ve eğrileri iki örnek üzerinde görelim. Bir rasgele
tepe, ve bir rasgele yol çiziyoruz,</p>
<pre><code class="python">from mpl_toolkits.mplot3d import Axes3D
from scipy.spatial.distance import cdist
from matplotlib import cm

def gfunc(x, y):
    s1 = 2.2; x1 = 2.0; y1 = 2.0
    g1 = np.exp( -4 *np.log(2) * ((x-x1)**2+(y-y1)**2) / s1**2)
    return g1 

def plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4):

    D = 50
    x = np.linspace(0,5,D)
    y = np.linspace(0,5,D)
    xx,yy = np.meshgrid(x,y)
    zz = gfunc(xx,yy)

    fig = plt.figure()
    ax = fig.gca(projection='3d')
    ax.set_xlim(0,5)
    ax.set_ylim(0,5)
    surf = ax.plot_wireframe(xx, yy, zz,rstride=10, cstride=10)

    t = np.linspace(0,1.0,100)

    x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
    y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4

    ax.plot3D(x, y, gfunc(x,y),'r.')

# 1. gidis yolunun tanimi, uzun yoldan dolanarak gidiyor
a1,a2,a3 = 1.5, 8.1, 4.0
b1,b2,b3 = 0.3, 0.4, 23.3
a0,b0=(1.0,1.0)
ex,ey=(0.3,4.0)
a4 = ex - a0 - (a1+a2+a3)
b4 = ey - b0 - (b1+b2+b3)
test_coefs1 = (a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)

plt.savefig('calc_multi_40_elev_01.png')
</code></pre>

<p><img alt="" src="calc_multi_40_elev_01.png" /></p>
<p>Eğer üstteki gidiş yoluna kuşbakışı, iki boyutlu ortamda bakmak istersek,</p>
<pre><code class="python">t = np.linspace(0,1.0,100)
x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4
plt.xlim(0,5.0)
plt.ylim(0,5.0)
plt.plot(x,y)
plt.savefig('calc_multi_40_elev_02.png')
</code></pre>

<p><img alt="" src="calc_multi_40_elev_02.png" /></p>
<p>Şimdi ikinci bir gidiş yoluna bakalım, başlangıç noktası aynı ama bitiş farklı,</p>
<pre><code class="python"># 2. gidis yolunun tanimi, dik cikip iniyor
a1,a2,a3 = 1.5, 3.0, 1.0
b1,b2,b3 = 0.0, 1.0, 1.0
a0,b0=(1.0,1.0)
ex,ey=(0.3,4.0)
a4 = ex - a0 - (a1+a2+a3)
b4 = ey - b0 - (b1+b2+b3)
test_coefs2 = (a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plot_surf_path(a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
plt.savefig('calc_multi_40_elev_03.png')
</code></pre>

<p><img alt="" src="calc_multi_40_elev_03.png" /></p>
<p>Bu yolları tabii ki rasgele parametreler üzerinden yarattık, bunlar optimal
yollar değiller.</p>
<p>Optimallik için gereken uzunluk hesabına gelelim. Bu hesap için
formül,</p>
<p>xxxxxxxxxxxxxx</p>
<p>$$
I_v = \int_{t=0}^{t=1} \sqrt{1 + \left(\frac{\mathrm{d} z}{\mathrm{d} t} \right)^2 } \mathrm{d} t
$$</p>
<p>$$
I_h = \int_{t=0}^{t=1} \sqrt{
\left(\frac{\mathrm{d} x}{\mathrm{d} t} \right)^2 + 
\left(\frac{\mathrm{d} y}{\mathrm{d} t} \right)^2
} 
\mathrm{d} t
$$</p>
<p>Formülde görülen $\mathrm{d} x/\mathrm{d} t$ ve $\mathrm{d} y/\mathrm{d} t$, parametrik eğri formülünü
tekrar yazalım, </p>
<p>$$
x(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3
$$</p>
<p>$$
y(t) = b_0 + b_1 t + b_2 t^2 + b_3 t^3
$$</p>
<p>ve türev, bunların karesi hesaplarını sembolik olarak altta yapalım,</p>
<pre><code class="python">import sympy

vars = 't a0 a1 a2 a3 b0 b1 b2 b3 gamma x y'
t, a0, a1, a2, a3, b0, b1, b2, b3, gamma, x, y = sympy.symbols(vars)

xdef = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4
ydef = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4

dxdt = sympy.diff(xdef,t)
print (dxdt)
dydt = sympy.diff(ydef,t)
print (dydt)
sqrtdef = sympy.sqrt(sympy.diff(xdef,t)**2 + sympy.diff(ydef,t))
print (sqrtdef)
</code></pre>

<pre><code>a1 + 2*a2*t + 3*a3*t**2 - 57.2*t**3
b1 + 2*b2*t + 3*b3*t**2 - 84.0*t**3
sqrt(b1 + 2*b2*t + 3*b3*t**2 - 84.0*t**3 + (a1 + 2*a2*t + 3*a3*t**2 - 57.2*t**3)**2)
</code></pre>

<pre><code class="python">import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from scipy.spatial.distance import cdist
from matplotlib import cm
import util

def trapz(y, dx):
    vals = y[1:-1]
    vals = vals[vals&gt;0.0]
    return (y[0]+np.sum(vals*2.0)+y[-1])*(dx/2.0)

def gfunc(x):
    t = x[0]
    x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 
    y = b0 + b1*t + b2*t**2 + b3*t**3 + b4*t**4
    s1 = 2.2; x1 = 2.0; y1 = 2.0
    g1 = np.exp( -4 *np.log(2) * ((x-x1)**2+(y-y1)**2) / s1**2)
    return g1

def calc_int(pars):
    pars = a0,a1,a2,a3,a4,b0,b1,b2,b3,b4
    ts = np.linspace(0,1.0,100)
    # for z 
    dzs = np.array([util._approx_fprime_helper([t],gfunc)[0] for t in ts])
    tmp = 1 + np.sqrt(1+dzs**2)
    Iv = trapz(tmp, 1/100.)
    print (Iv)
    tmp = np.array([b1 + 2*b2*t + 3*b3*t**2 - 112.0*t**3 + (a1 + 2*a2*t + 3*a3*t**2 - 65.2*t**3)**2 for t in ts])
    tmp = tmp[tmp&gt;0.0]
    tmp = np.sqrt(tmp)
    Ih = trapz(tmp, 1/100.)
    return Iv*5 + Ih*1


# 1. gidis yolunun tanimi, uzun yoldan dolanarak gidiyor
#a1,a2,a3 = 1.5, 8.1, 4.0
#b1,b2,b3 = 0.3, 0.4, 23.3
a1,a2,a3 = 1.5, 3.0, 1.0
b1,b2,b3 = 0.0, 1.0, 1.0
a0,b0=(1.0,1.0)
ex,ey=(0.3,4.0)
a4 = ex - a0 - (a1+a2+a3)
b4 = ey - b0 - (b1+b2+b3)
test_coefs1 = (a0,a1,a2,a3,a4,b0,b1,b2,b3,b4)
print (calc_int(test_coefs1))
</code></pre>

<p>Kaynaklar </p>
<p>[1] Bayramlı, Sayısal Bilim, <em>Sayısal Entegrasyon (Numerical Integration)</em></p>
<p>[2] Bayramlı, Cok Boyutlu Calculus, <em>Ders 19, Skalar Alanlar Uzerinden Cizgi Entegral</em></p>
<p>[3] Bayramlı, Cok Boyutlu Calculus, <em>Ders 5, İki Nokta Arasında Parametrize Edilmiş Eğri</em></p>
<p>[4] Bayramlı, İstatistik ve Veri Analizi, <em>Dairesel Baz Fonksiyonları (Radial Basis Functions -RBF-)</em></p>
<p>[5] Bayramlı, Fonksiyonel Analiz ve Optimizasyon, *Newton-umsu Metotlar, DFP, BFGS *</p>